/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/[tag]/res/[thread]",{

/***/ "./node_modules/@bbob/parser/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@bbob/parser/dist/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("(function (global, factory) {\n    true ? factory(exports, __webpack_require__(/*! @bbob/plugin-helper */ \"./node_modules/@bbob/plugin-helper/dist/index.js\")) :\n   0;\n})(this, (function (exports, pluginHelper) { 'use strict';\n\n   // type, value, line, row,\n   const TOKEN_TYPE_ID = 'type'; // 0;\n   const TOKEN_VALUE_ID = 'value'; // 1;\n   const TOKEN_COLUMN_ID = 'row'; // 2;\n   const TOKEN_LINE_ID = 'line'; // 3;\n   const TOKEN_TYPE_WORD = 1; // 'word';\n   const TOKEN_TYPE_TAG = 2; // 'tag';\n   const TOKEN_TYPE_ATTR_NAME = 3; // 'attr-name';\n   const TOKEN_TYPE_ATTR_VALUE = 4; // 'attr-value';\n   const TOKEN_TYPE_SPACE = 5; // 'space';\n   const TOKEN_TYPE_NEW_LINE = 6; // 'new-line';\n   /**\n    * @param {Token} token\n    * @returns {string}\n    */ const getTokenValue = (token)=>{\n       if (token && typeof token[TOKEN_VALUE_ID] !== 'undefined') {\n           return token[TOKEN_VALUE_ID];\n       }\n       return '';\n   };\n   /**\n    * @param {Token}token\n    * @returns {number}\n    */ const getTokenLine = (token)=>token && token[TOKEN_LINE_ID] || 0;\n   const getTokenColumn = (token)=>token && token[TOKEN_COLUMN_ID] || 0;\n   /**\n    * @param {Token} token\n    * @returns {boolean}\n    */ const isTextToken = (token)=>{\n       if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {\n           return token[TOKEN_TYPE_ID] === TOKEN_TYPE_SPACE || token[TOKEN_TYPE_ID] === TOKEN_TYPE_NEW_LINE || token[TOKEN_TYPE_ID] === TOKEN_TYPE_WORD;\n       }\n       return false;\n   };\n   /**\n    * @param {Token} token\n    * @returns {boolean}\n    */ const isTagToken = (token)=>{\n       if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {\n           return token[TOKEN_TYPE_ID] === TOKEN_TYPE_TAG;\n       }\n       return false;\n   };\n   const isTagEnd = (token)=>getTokenValue(token).charCodeAt(0) === pluginHelper.SLASH.charCodeAt(0);\n   const isTagStart = (token)=>!isTagEnd(token);\n   const isAttrNameToken = (token)=>{\n       if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {\n           return token[TOKEN_TYPE_ID] === TOKEN_TYPE_ATTR_NAME;\n       }\n       return false;\n   };\n   /**\n    * @param {Token} token\n    * @returns {boolean}\n    */ const isAttrValueToken = (token)=>{\n       if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {\n           return token[TOKEN_TYPE_ID] === TOKEN_TYPE_ATTR_VALUE;\n       }\n       return false;\n   };\n   const getTagName = (token)=>{\n       const value = getTokenValue(token);\n       return isTagEnd(token) ? value.slice(1) : value;\n   };\n   const convertTagToText = (token)=>{\n       let text = pluginHelper.OPEN_BRAKET;\n       text += getTokenValue(token);\n       text += pluginHelper.CLOSE_BRAKET;\n       return text;\n   };\n   class Token {\n       isEmpty() {\n           // eslint-disable-next-line no-restricted-globals\n           return isNaN(this[TOKEN_TYPE_ID]);\n       }\n       isText() {\n           return isTextToken(this);\n       }\n       isTag() {\n           return isTagToken(this);\n       }\n       isAttrName() {\n           return isAttrNameToken(this);\n       }\n       isAttrValue() {\n           return isAttrValueToken(this);\n       }\n       isStart() {\n           return isTagStart(this);\n       }\n       isEnd() {\n           return isTagEnd(this);\n       }\n       getName() {\n           return getTagName(this);\n       }\n       getValue() {\n           return getTokenValue(this);\n       }\n       getLine() {\n           return getTokenLine(this);\n       }\n       getColumn() {\n           return getTokenColumn(this);\n       }\n       toString() {\n           return convertTagToText(this);\n       }\n       /**\n      * @param {String} type\n      * @param {String} value\n      * @param line\n      * @param row\n      */ constructor(type, value, line, row){\n           this[TOKEN_TYPE_ID] = Number(type);\n           this[TOKEN_VALUE_ID] = String(value);\n           this[TOKEN_LINE_ID] = Number(line);\n           this[TOKEN_COLUMN_ID] = Number(row);\n       }\n   }\n   const TYPE_WORD = TOKEN_TYPE_WORD;\n   const TYPE_TAG = TOKEN_TYPE_TAG;\n   const TYPE_ATTR_NAME = TOKEN_TYPE_ATTR_NAME;\n   const TYPE_ATTR_VALUE = TOKEN_TYPE_ATTR_VALUE;\n   const TYPE_SPACE = TOKEN_TYPE_SPACE;\n   const TYPE_NEW_LINE = TOKEN_TYPE_NEW_LINE;\n\n   function CharGrabber(source, options) {\n       const cursor = {\n           pos: 0,\n           len: source.length\n       };\n       const substrUntilChar = (char)=>{\n           const { pos  } = cursor;\n           const idx = source.indexOf(char, pos);\n           return idx >= 0 ? source.substring(pos, idx) : '';\n       };\n       const includes = (val)=>source.indexOf(val, cursor.pos) >= 0;\n       const hasNext = ()=>cursor.len > cursor.pos;\n       const isLast = ()=>cursor.pos === cursor.len;\n       const skip = (num = 1, silent)=>{\n           cursor.pos += num;\n           if (options && options.onSkip && !silent) {\n               options.onSkip();\n           }\n       };\n       const rest = ()=>source.substring(cursor.pos);\n       const grabN = (num = 0)=>source.substring(cursor.pos, cursor.pos + num);\n       const curr = ()=>source[cursor.pos];\n       const prev = ()=>{\n           const prevPos = cursor.pos - 1;\n           return typeof source[prevPos] !== 'undefined' ? source[prevPos] : null;\n       };\n       const next = ()=>{\n           const nextPos = cursor.pos + 1;\n           return nextPos <= source.length - 1 ? source[nextPos] : null;\n       };\n       const grabWhile = (cond, silent)=>{\n           let start = 0;\n           if (hasNext()) {\n               start = cursor.pos;\n               while(hasNext() && cond(curr())){\n                   skip(1, silent);\n               }\n           }\n           return source.substring(start, cursor.pos);\n       };\n       /**\n      * @type {skip}\n      */ this.skip = skip;\n       /**\n      * @returns {Boolean}\n      */ this.hasNext = hasNext;\n       /**\n      * @returns {String}\n      */ this.getCurr = curr;\n       /**\n      * @returns {String}\n      */ this.getRest = rest;\n       /**\n      * @returns {String}\n      */ this.getNext = next;\n       /**\n      * @returns {String}\n      */ this.getPrev = prev;\n       /**\n      * @returns {Boolean}\n      */ this.isLast = isLast;\n       /**\n      * @returns {Boolean}\n      */ this.includes = includes;\n       /**\n      * @param {Function} cond\n      * @param {Boolean} silent\n      * @return {String}\n      */ this.grabWhile = grabWhile;\n       /**\n      * @param {Number} num\n      * @return {String}\n      */ this.grabN = grabN;\n       /**\n      * Grabs rest of string until it find a char\n      * @param {String} char\n      * @return {String}\n      */ this.substrUntilChar = substrUntilChar;\n   }\n   /**\n    * Creates a grabber wrapper for source string, that helps to iterate over string char by char\n    * @param {String} source\n    * @param {Object} options\n    * @param {Function} options.onSkip\n    * @return CharGrabber\n    */ const createCharGrabber = (source, options)=>new CharGrabber(source, options);\n   /**\n    * Trims string from start and end by char\n    * @example\n    *  trimChar('*hello*', '*') ==> 'hello'\n    * @param {String} str\n    * @param {String} charToRemove\n    * @returns {String}\n    */ const trimChar = (str, charToRemove)=>{\n       while(str.charAt(0) === charToRemove){\n           // eslint-disable-next-line no-param-reassign\n           str = str.substring(1);\n       }\n       while(str.charAt(str.length - 1) === charToRemove){\n           // eslint-disable-next-line no-param-reassign\n           str = str.substring(0, str.length - 1);\n       }\n       return str;\n   };\n   /**\n    * Unquotes \\\" to \"\n    * @param str\n    * @return {String}\n    */ const unquote = (str)=>str.replace(pluginHelper.BACKSLASH + pluginHelper.QUOTEMARK, pluginHelper.QUOTEMARK);\n   function NodeList(values = []) {\n       const nodes = values;\n       const getLast = ()=>Array.isArray(nodes) && nodes.length > 0 && typeof nodes[nodes.length - 1] !== 'undefined' ? nodes[nodes.length - 1] : null;\n       const flushLast = ()=>nodes.length ? nodes.pop() : false;\n       const push = (value)=>nodes.push(value);\n       const toArray = ()=>nodes;\n       this.push = push;\n       this.toArray = toArray;\n       this.getLast = getLast;\n       this.flushLast = flushLast;\n   }\n   /**\n    *\n    * @param values\n    * @return {NodeList}\n    */ const createList = (values = [])=>new NodeList(values);\n\n   // for cases <!-- -->\n   const EM = '!';\n   /**\n    * Creates a Token entity class\n    * @param {Number} type\n    * @param {String} value\n    * @param {Number} r line number\n    * @param {Number} cl char number in line\n    */ const createToken = (type, value, r = 0, cl = 0)=>new Token(type, value, r, cl);\n   /**\n    * @typedef {Object} Lexer\n    * @property {Function} tokenize\n    * @property {Function} isTokenNested\n    */ /**\n    * @param {String} buffer\n    * @param {Object} options\n    * @param {Function} options.onToken\n    * @param {String} options.openTag\n    * @param {String} options.closeTag\n    * @param {Boolean} options.enableEscapeTags\n    * @return {Lexer}\n    */ function createLexer(buffer, options = {}) {\n       const STATE_WORD = 0;\n       const STATE_TAG = 1;\n       const STATE_TAG_ATTRS = 2;\n       const TAG_STATE_NAME = 0;\n       const TAG_STATE_ATTR = 1;\n       const TAG_STATE_VALUE = 2;\n       let row = 0;\n       let col = 0;\n       let tokenIndex = -1;\n       let stateMode = STATE_WORD;\n       let tagMode = TAG_STATE_NAME;\n       let contextFreeTag = '';\n       const tokens = new Array(Math.floor(buffer.length));\n       const openTag = options.openTag || pluginHelper.OPEN_BRAKET;\n       const closeTag = options.closeTag || pluginHelper.CLOSE_BRAKET;\n       const escapeTags = !!options.enableEscapeTags;\n       const contextFreeTags = options.contextFreeTags || [];\n       const onToken = options.onToken || (()=>{});\n       const RESERVED_CHARS = [\n           closeTag,\n           openTag,\n           pluginHelper.QUOTEMARK,\n           pluginHelper.BACKSLASH,\n           pluginHelper.SPACE,\n           pluginHelper.TAB,\n           pluginHelper.EQ,\n           pluginHelper.N,\n           EM\n       ];\n       const NOT_CHAR_TOKENS = [\n           openTag,\n           pluginHelper.SPACE,\n           pluginHelper.TAB,\n           pluginHelper.N\n       ];\n       const WHITESPACES = [\n           pluginHelper.SPACE,\n           pluginHelper.TAB\n       ];\n       const SPECIAL_CHARS = [\n           pluginHelper.EQ,\n           pluginHelper.SPACE,\n           pluginHelper.TAB\n       ];\n       const isCharReserved = (char)=>RESERVED_CHARS.indexOf(char) >= 0;\n       const isNewLine = (char)=>char === pluginHelper.N;\n       const isWhiteSpace = (char)=>WHITESPACES.indexOf(char) >= 0;\n       const isCharToken = (char)=>NOT_CHAR_TOKENS.indexOf(char) === -1;\n       const isSpecialChar = (char)=>SPECIAL_CHARS.indexOf(char) >= 0;\n       const isEscapableChar = (char)=>char === openTag || char === closeTag || char === pluginHelper.BACKSLASH;\n       const isEscapeChar = (char)=>char === pluginHelper.BACKSLASH;\n       const onSkip = ()=>{\n           col++;\n       };\n       const unq = (val)=>unquote(trimChar(val, pluginHelper.QUOTEMARK));\n       const checkContextFreeMode = (name, isClosingTag)=>{\n           if (contextFreeTag !== '' && isClosingTag) {\n               contextFreeTag = '';\n           }\n           if (contextFreeTag === '' && contextFreeTags.includes(name)) {\n               contextFreeTag = name;\n           }\n       };\n       const chars = createCharGrabber(buffer, {\n           onSkip\n       });\n       /**\n      * Emits newly created token to subscriber\n      * @param {Number} type\n      * @param {String} value\n      */ function emitToken(type, value) {\n           const token = createToken(type, value, row, col);\n           onToken(token);\n           tokenIndex += 1;\n           tokens[tokenIndex] = token;\n       }\n       function nextTagState(tagChars, isSingleValueTag) {\n           if (tagMode === TAG_STATE_ATTR) {\n               const validAttrName = (char)=>!(char === pluginHelper.EQ || isWhiteSpace(char));\n               const name = tagChars.grabWhile(validAttrName);\n               const isEnd = tagChars.isLast();\n               const isValue = tagChars.getCurr() !== pluginHelper.EQ;\n               tagChars.skip();\n               if (isEnd || isValue) {\n                   emitToken(TYPE_ATTR_VALUE, unq(name));\n               } else {\n                   emitToken(TYPE_ATTR_NAME, name);\n               }\n               if (isEnd) {\n                   return TAG_STATE_NAME;\n               }\n               if (isValue) {\n                   return TAG_STATE_ATTR;\n               }\n               return TAG_STATE_VALUE;\n           }\n           if (tagMode === TAG_STATE_VALUE) {\n               let stateSpecial = false;\n               const validAttrValue = (char)=>{\n                   // const isEQ = char === EQ;\n                   const isQM = char === pluginHelper.QUOTEMARK;\n                   const prevChar = tagChars.getPrev();\n                   const nextChar = tagChars.getNext();\n                   const isPrevSLASH = prevChar === pluginHelper.BACKSLASH;\n                   const isNextEQ = nextChar === pluginHelper.EQ;\n                   const isWS = isWhiteSpace(char);\n                   // const isPrevWS = isWhiteSpace(prevChar);\n                   const isNextWS = isWhiteSpace(nextChar);\n                   if (stateSpecial && isSpecialChar(char)) {\n                       return true;\n                   }\n                   if (isQM && !isPrevSLASH) {\n                       stateSpecial = !stateSpecial;\n                       if (!stateSpecial && !(isNextEQ || isNextWS)) {\n                           return false;\n                       }\n                   }\n                   if (!isSingleValueTag) {\n                       return isWS === false;\n                   // return (isEQ || isWS) === false;\n                   }\n                   return true;\n               };\n               const name1 = tagChars.grabWhile(validAttrValue);\n               tagChars.skip();\n               emitToken(TYPE_ATTR_VALUE, unq(name1));\n               if (tagChars.isLast()) {\n                   return TAG_STATE_NAME;\n               }\n               return TAG_STATE_ATTR;\n           }\n           const validName = (char)=>!(char === pluginHelper.EQ || isWhiteSpace(char) || tagChars.isLast());\n           const name2 = tagChars.grabWhile(validName);\n           emitToken(TYPE_TAG, name2);\n           checkContextFreeMode(name2);\n           tagChars.skip();\n           // in cases when we has [url=someval]GET[/url] and we dont need to parse all\n           if (isSingleValueTag) {\n               return TAG_STATE_VALUE;\n           }\n           const hasEQ = tagChars.includes(pluginHelper.EQ);\n           return hasEQ ? TAG_STATE_ATTR : TAG_STATE_VALUE;\n       }\n       function stateTag() {\n           const currChar = chars.getCurr();\n           const nextChar = chars.getNext();\n           chars.skip();\n           // detect case where we have '[My word [tag][/tag]' or we have '[My last line word'\n           const substr = chars.substrUntilChar(closeTag);\n           const hasInvalidChars = substr.length === 0 || substr.indexOf(openTag) >= 0;\n           if (isCharReserved(nextChar) || hasInvalidChars || chars.isLast()) {\n               emitToken(TYPE_WORD, currChar);\n               return STATE_WORD;\n           }\n           // [myTag   ]\n           const isNoAttrsInTag = substr.indexOf(pluginHelper.EQ) === -1;\n           // [/myTag]\n           const isClosingTag = substr[0] === pluginHelper.SLASH;\n           if (isNoAttrsInTag || isClosingTag) {\n               const name = chars.grabWhile((char)=>char !== closeTag);\n               chars.skip(); // skip closeTag\n               emitToken(TYPE_TAG, name);\n               checkContextFreeMode(name, isClosingTag);\n               return STATE_WORD;\n           }\n           return STATE_TAG_ATTRS;\n       }\n       function stateAttrs() {\n           const silent = true;\n           const tagStr = chars.grabWhile((char)=>char !== closeTag, silent);\n           const tagGrabber = createCharGrabber(tagStr, {\n               onSkip\n           });\n           const hasSpace = tagGrabber.includes(pluginHelper.SPACE);\n           tagMode = TAG_STATE_NAME;\n           while(tagGrabber.hasNext()){\n               tagMode = nextTagState(tagGrabber, !hasSpace);\n           }\n           chars.skip(); // skip closeTag\n           return STATE_WORD;\n       }\n       function stateWord() {\n           if (isNewLine(chars.getCurr())) {\n               emitToken(TYPE_NEW_LINE, chars.getCurr());\n               chars.skip();\n               col = 0;\n               row++;\n               return STATE_WORD;\n           }\n           if (isWhiteSpace(chars.getCurr())) {\n               const word = chars.grabWhile(isWhiteSpace);\n               emitToken(TYPE_SPACE, word);\n               return STATE_WORD;\n           }\n           if (chars.getCurr() === openTag) {\n               if (contextFreeTag) {\n                   const fullTagLen = openTag.length + pluginHelper.SLASH.length + contextFreeTag.length;\n                   const fullTagName = `${openTag}${pluginHelper.SLASH}${contextFreeTag}`;\n                   const foundTag = chars.grabN(fullTagLen);\n                   const isEndContextFreeMode = foundTag === fullTagName;\n                   if (isEndContextFreeMode) {\n                       return STATE_TAG;\n                   }\n               } else if (chars.includes(closeTag)) {\n                   return STATE_TAG;\n               }\n               emitToken(TYPE_WORD, chars.getCurr());\n               chars.skip();\n               return STATE_WORD;\n           }\n           if (escapeTags) {\n               if (isEscapeChar(chars.getCurr())) {\n                   const currChar = chars.getCurr();\n                   const nextChar = chars.getNext();\n                   chars.skip(); // skip the \\ without emitting anything\n                   if (isEscapableChar(nextChar)) {\n                       chars.skip(); // skip past the [, ] or \\ as well\n                       emitToken(TYPE_WORD, nextChar);\n                       return STATE_WORD;\n                   }\n                   emitToken(TYPE_WORD, currChar);\n                   return STATE_WORD;\n               }\n               const isChar = (char)=>isCharToken(char) && !isEscapeChar(char);\n               const word1 = chars.grabWhile(isChar);\n               emitToken(TYPE_WORD, word1);\n               return STATE_WORD;\n           }\n           const word2 = chars.grabWhile(isCharToken);\n           emitToken(TYPE_WORD, word2);\n           return STATE_WORD;\n       }\n       function tokenize() {\n           stateMode = STATE_WORD;\n           while(chars.hasNext()){\n               switch(stateMode){\n                   case STATE_TAG:\n                       stateMode = stateTag();\n                       break;\n                   case STATE_TAG_ATTRS:\n                       stateMode = stateAttrs();\n                       break;\n                   case STATE_WORD:\n                   default:\n                       stateMode = stateWord();\n                       break;\n               }\n           }\n           tokens.length = tokenIndex + 1;\n           return tokens;\n       }\n       function isTokenNested(token) {\n           const value = openTag + pluginHelper.SLASH + token.getValue();\n           // potential bottleneck\n           return buffer.indexOf(value) > -1;\n       }\n       return {\n           tokenize,\n           isTokenNested\n       };\n   }\n\n   /**\n    * @public\n    * @param {string} input\n    * @param {Object} opts\n    * @param {Function} opts.createTokenizer\n    * @param {Array<string>} opts.onlyAllowTags\n    * @param {Array<string>} opts.contextFreeTags\n    * @param {Boolean} opts.enableEscapeTags\n    * @param {string} opts.openTag\n    * @param {string} opts.closeTag\n    * @return {Array<string|TagNode>}\n    */ const parse = (input, opts = {})=>{\n       const options = opts;\n       const openTag = options.openTag || pluginHelper.OPEN_BRAKET;\n       const closeTag = options.closeTag || pluginHelper.CLOSE_BRAKET;\n       const onlyAllowTags = (options.onlyAllowTags || []).filter(Boolean).map((tag)=>tag.toLowerCase());\n       let tokenizer = null;\n       /**\n      * Result AST of nodes\n      * @private\n      * @type {NodeList}\n      */ const nodes = createList();\n       /**\n      * Temp buffer of nodes that's nested to another node\n      * @private\n      * @type {NodeList}\n      */ const nestedNodes = createList();\n       /**\n      * Temp buffer of nodes [tag..]...[/tag]\n      * @private\n      * @type {NodeList}\n      */ const tagNodes = createList();\n       /**\n      * Temp buffer of tag attributes\n      * @private\n      * @type {NodeList}\n      */ const tagNodesAttrName = createList();\n       /**\n      * Cache for nested tags checks\n      * @type Set<string>\n      */ const nestedTagsMap = new Set();\n       /**\n      * @param {Token} token\n      * @returns {boolean}\n      */ const isTokenNested = (token)=>{\n           const value = token.getValue();\n           if (!nestedTagsMap.has(value) && tokenizer.isTokenNested && tokenizer.isTokenNested(token)) {\n               nestedTagsMap.add(value);\n               return true;\n           }\n           return nestedTagsMap.has(value);\n       };\n       /**\n      * @private\n      * @param {string} tagName\n      * @returns {boolean}\n      */ const isTagNested = (tagName)=>Boolean(nestedTagsMap.has(tagName));\n       /**\n      * @private\n      * @param {string} value\n      * @return {boolean}\n      */ const isAllowedTag = (value)=>{\n           if (onlyAllowTags.length) {\n               return onlyAllowTags.indexOf(value.toLowerCase()) >= 0;\n           }\n           return true;\n       };\n       /**\n      * Flushes temp tag nodes and its attributes buffers\n      * @private\n      * @return {Array}\n      */ const flushTagNodes = ()=>{\n           if (tagNodes.flushLast()) {\n               tagNodesAttrName.flushLast();\n           }\n       };\n       /**\n      * @private\n      * @return {Array}\n      */ const getNodes = ()=>{\n           const lastNestedNode = nestedNodes.getLast();\n           if (lastNestedNode && Array.isArray(lastNestedNode.content)) {\n               return lastNestedNode.content;\n           }\n           return nodes.toArray();\n       };\n       /**\n      * @private\n      * @param {string|TagNode} node\n      * @param {boolean} isNested\n      */ const appendNodeAsString = (node, isNested = true)=>{\n           const items = getNodes();\n           if (Array.isArray(items)) {\n               items.push(node.toTagStart({\n                   openTag,\n                   closeTag\n               }));\n               if (node.content.length) {\n                   node.content.forEach((item)=>{\n                       items.push(item);\n                   });\n                   if (isNested) {\n                       items.push(node.toTagEnd({\n                           openTag,\n                           closeTag\n                       }));\n                   }\n               }\n           }\n       };\n       /**\n      * @private\n      * @param {string|TagNode} node\n      */ const appendNodes = (node)=>{\n           const items = getNodes();\n           if (Array.isArray(items)) {\n               if (pluginHelper.isTagNode(node)) {\n                   if (isAllowedTag(node.tag)) {\n                       items.push(node.toTagNode());\n                   } else {\n                       appendNodeAsString(node);\n                   }\n               } else {\n                   items.push(node);\n               }\n           }\n       };\n       /**\n      * @private\n      * @param {Token} token\n      */ const handleTagStart = (token)=>{\n           flushTagNodes();\n           const tagNode = pluginHelper.TagNode.create(token.getValue());\n           const isNested = isTokenNested(token);\n           tagNodes.push(tagNode);\n           if (isNested) {\n               nestedNodes.push(tagNode);\n           } else {\n               appendNodes(tagNode);\n           }\n       };\n       /**\n      * @private\n      * @param {Token} token\n      */ const handleTagEnd = (token)=>{\n           flushTagNodes();\n           const lastNestedNode = nestedNodes.flushLast();\n           if (lastNestedNode) {\n               appendNodes(lastNestedNode);\n           } else if (typeof options.onError === 'function') {\n               const tag = token.getValue();\n               const line = token.getLine();\n               const column = token.getColumn();\n               options.onError({\n                   message: `Inconsistent tag '${tag}' on line ${line} and column ${column}`,\n                   tagName: tag,\n                   lineNumber: line,\n                   columnNumber: column\n               });\n           }\n       };\n       /**\n      * @private\n      * @param {Token} token\n      */ const handleTag = (token)=>{\n           // [tag]\n           if (token.isStart()) {\n               handleTagStart(token);\n           }\n           // [/tag]\n           if (token.isEnd()) {\n               handleTagEnd(token);\n           }\n       };\n       /**\n      * @private\n      * @param {Token} token\n      */ const handleNode = (token)=>{\n           /**\n        * @type {TagNode}\n        */ const lastTagNode = tagNodes.getLast();\n           const tokenValue = token.getValue();\n           const isNested = isTagNested(token);\n           if (lastTagNode) {\n               if (token.isAttrName()) {\n                   tagNodesAttrName.push(tokenValue);\n                   lastTagNode.attr(tagNodesAttrName.getLast(), '');\n               } else if (token.isAttrValue()) {\n                   const attrName = tagNodesAttrName.getLast();\n                   if (attrName) {\n                       lastTagNode.attr(attrName, tokenValue);\n                       tagNodesAttrName.flushLast();\n                   } else {\n                       lastTagNode.attr(tokenValue, tokenValue);\n                   }\n               } else if (token.isText()) {\n                   if (isNested) {\n                       lastTagNode.append(tokenValue);\n                   } else {\n                       appendNodes(tokenValue);\n                   }\n               } else if (token.isTag()) {\n                   // if tag is not allowed, just past it as is\n                   appendNodes(token.toString());\n               }\n           } else if (token.isText()) {\n               appendNodes(tokenValue);\n           } else if (token.isTag()) {\n               // if tag is not allowed, just past it as is\n               appendNodes(token.toString());\n           }\n       };\n       /**\n      * @private\n      * @param {Token} token\n      */ const onToken = (token)=>{\n           if (token.isTag()) {\n               handleTag(token);\n           } else {\n               handleNode(token);\n           }\n       };\n       tokenizer = (opts.createTokenizer ? opts.createTokenizer : createLexer)(input, {\n           onToken,\n           openTag,\n           closeTag,\n           onlyAllowTags: options.onlyAllowTags,\n           contextFreeTags: options.contextFreeTags,\n           enableEscapeTags: options.enableEscapeTags\n       });\n       // eslint-disable-next-line no-unused-vars\n       tokenizer.tokenize();\n       // handles situations where we open tag, but forgot close them\n       // for ex [q]test[/q][u]some[/u][q]some [u]some[/u] // forgot to close [/q]\n       // so we need to flush nested content to nodes array\n       const lastNestedNode = nestedNodes.flushLast();\n       if (lastNestedNode && isTagNested(lastNestedNode.tag)) {\n           appendNodeAsString(lastNestedNode, false);\n       }\n       return nodes.toArray();\n   };\n\n   Object.defineProperty(exports, 'TagNode', {\n      enumerable: true,\n      get: function () { return pluginHelper.TagNode; }\n   });\n   exports.default = parse;\n   exports.parse = parse;\n\n   Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJib2IvcGFyc2VyL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxHQUFHLEtBQTRELG9CQUFvQixtQkFBTyxDQUFDLDZFQUFxQjtBQUNoSCxHQUFHLENBQ2dJO0FBQ25JLENBQUMsNENBQTRDOztBQUU3QztBQUNBLGlDQUFpQztBQUNqQyxtQ0FBbUM7QUFDbkMsa0NBQWtDO0FBQ2xDLGlDQUFpQztBQUNqQyw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLG1DQUFtQztBQUNuQyxvQ0FBb0M7QUFDcEMsK0JBQStCO0FBQy9CLGtDQUFrQztBQUNsQztBQUNBLGNBQWMsT0FBTztBQUNyQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxJQUFJLFlBQVksTUFBTSxhQUFhLE9BQU87QUFDM0Y7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixJQUFJO0FBQ0o7QUFDQTs7QUFFQSxrREFBa0QsYUFBYTs7QUFFL0QsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJib2IvcGFyc2VyL2Rpc3QvaW5kZXguanM/ZWE0MCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdAYmJvYi9wbHVnaW4taGVscGVyJykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnQGJib2IvcGx1Z2luLWhlbHBlciddLCBmYWN0b3J5KSA6XG4gICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5CYm9iUGFyc2VyID0ge30sIGdsb2JhbC5wbHVnaW5IZWxwZXIpKTtcbn0pKHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cywgcGx1Z2luSGVscGVyKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgLy8gdHlwZSwgdmFsdWUsIGxpbmUsIHJvdyxcbiAgIGNvbnN0IFRPS0VOX1RZUEVfSUQgPSAndHlwZSc7IC8vIDA7XG4gICBjb25zdCBUT0tFTl9WQUxVRV9JRCA9ICd2YWx1ZSc7IC8vIDE7XG4gICBjb25zdCBUT0tFTl9DT0xVTU5fSUQgPSAncm93JzsgLy8gMjtcbiAgIGNvbnN0IFRPS0VOX0xJTkVfSUQgPSAnbGluZSc7IC8vIDM7XG4gICBjb25zdCBUT0tFTl9UWVBFX1dPUkQgPSAxOyAvLyAnd29yZCc7XG4gICBjb25zdCBUT0tFTl9UWVBFX1RBRyA9IDI7IC8vICd0YWcnO1xuICAgY29uc3QgVE9LRU5fVFlQRV9BVFRSX05BTUUgPSAzOyAvLyAnYXR0ci1uYW1lJztcbiAgIGNvbnN0IFRPS0VOX1RZUEVfQVRUUl9WQUxVRSA9IDQ7IC8vICdhdHRyLXZhbHVlJztcbiAgIGNvbnN0IFRPS0VOX1RZUEVfU1BBQ0UgPSA1OyAvLyAnc3BhY2UnO1xuICAgY29uc3QgVE9LRU5fVFlQRV9ORVdfTElORSA9IDY7IC8vICduZXctbGluZSc7XG4gICAvKipcbiAgICAqIEBwYXJhbSB7VG9rZW59IHRva2VuXG4gICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICovIGNvbnN0IGdldFRva2VuVmFsdWUgPSAodG9rZW4pPT57XG4gICAgICAgaWYgKHRva2VuICYmIHR5cGVvZiB0b2tlbltUT0tFTl9WQUxVRV9JRF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgIHJldHVybiB0b2tlbltUT0tFTl9WQUxVRV9JRF07XG4gICAgICAgfVxuICAgICAgIHJldHVybiAnJztcbiAgIH07XG4gICAvKipcbiAgICAqIEBwYXJhbSB7VG9rZW59dG9rZW5cbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi8gY29uc3QgZ2V0VG9rZW5MaW5lID0gKHRva2VuKT0+dG9rZW4gJiYgdG9rZW5bVE9LRU5fTElORV9JRF0gfHwgMDtcbiAgIGNvbnN0IGdldFRva2VuQ29sdW1uID0gKHRva2VuKT0+dG9rZW4gJiYgdG9rZW5bVE9LRU5fQ09MVU1OX0lEXSB8fCAwO1xuICAgLyoqXG4gICAgKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgKi8gY29uc3QgaXNUZXh0VG9rZW4gPSAodG9rZW4pPT57XG4gICAgICAgaWYgKHRva2VuICYmIHR5cGVvZiB0b2tlbltUT0tFTl9UWVBFX0lEXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgcmV0dXJuIHRva2VuW1RPS0VOX1RZUEVfSURdID09PSBUT0tFTl9UWVBFX1NQQUNFIHx8IHRva2VuW1RPS0VOX1RZUEVfSURdID09PSBUT0tFTl9UWVBFX05FV19MSU5FIHx8IHRva2VuW1RPS0VOX1RZUEVfSURdID09PSBUT0tFTl9UWVBFX1dPUkQ7XG4gICAgICAgfVxuICAgICAgIHJldHVybiBmYWxzZTtcbiAgIH07XG4gICAvKipcbiAgICAqIEBwYXJhbSB7VG9rZW59IHRva2VuXG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAqLyBjb25zdCBpc1RhZ1Rva2VuID0gKHRva2VuKT0+e1xuICAgICAgIGlmICh0b2tlbiAmJiB0eXBlb2YgdG9rZW5bVE9LRU5fVFlQRV9JRF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgIHJldHVybiB0b2tlbltUT0tFTl9UWVBFX0lEXSA9PT0gVE9LRU5fVFlQRV9UQUc7XG4gICAgICAgfVxuICAgICAgIHJldHVybiBmYWxzZTtcbiAgIH07XG4gICBjb25zdCBpc1RhZ0VuZCA9ICh0b2tlbik9PmdldFRva2VuVmFsdWUodG9rZW4pLmNoYXJDb2RlQXQoMCkgPT09IHBsdWdpbkhlbHBlci5TTEFTSC5jaGFyQ29kZUF0KDApO1xuICAgY29uc3QgaXNUYWdTdGFydCA9ICh0b2tlbik9PiFpc1RhZ0VuZCh0b2tlbik7XG4gICBjb25zdCBpc0F0dHJOYW1lVG9rZW4gPSAodG9rZW4pPT57XG4gICAgICAgaWYgKHRva2VuICYmIHR5cGVvZiB0b2tlbltUT0tFTl9UWVBFX0lEXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgcmV0dXJuIHRva2VuW1RPS0VOX1RZUEVfSURdID09PSBUT0tFTl9UWVBFX0FUVFJfTkFNRTtcbiAgICAgICB9XG4gICAgICAgcmV0dXJuIGZhbHNlO1xuICAgfTtcbiAgIC8qKlxuICAgICogQHBhcmFtIHtUb2tlbn0gdG9rZW5cbiAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICovIGNvbnN0IGlzQXR0clZhbHVlVG9rZW4gPSAodG9rZW4pPT57XG4gICAgICAgaWYgKHRva2VuICYmIHR5cGVvZiB0b2tlbltUT0tFTl9UWVBFX0lEXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgcmV0dXJuIHRva2VuW1RPS0VOX1RZUEVfSURdID09PSBUT0tFTl9UWVBFX0FUVFJfVkFMVUU7XG4gICAgICAgfVxuICAgICAgIHJldHVybiBmYWxzZTtcbiAgIH07XG4gICBjb25zdCBnZXRUYWdOYW1lID0gKHRva2VuKT0+e1xuICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0VG9rZW5WYWx1ZSh0b2tlbik7XG4gICAgICAgcmV0dXJuIGlzVGFnRW5kKHRva2VuKSA/IHZhbHVlLnNsaWNlKDEpIDogdmFsdWU7XG4gICB9O1xuICAgY29uc3QgY29udmVydFRhZ1RvVGV4dCA9ICh0b2tlbik9PntcbiAgICAgICBsZXQgdGV4dCA9IHBsdWdpbkhlbHBlci5PUEVOX0JSQUtFVDtcbiAgICAgICB0ZXh0ICs9IGdldFRva2VuVmFsdWUodG9rZW4pO1xuICAgICAgIHRleHQgKz0gcGx1Z2luSGVscGVyLkNMT1NFX0JSQUtFVDtcbiAgICAgICByZXR1cm4gdGV4dDtcbiAgIH07XG4gICBjbGFzcyBUb2tlbiB7XG4gICAgICAgaXNFbXB0eSgpIHtcbiAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgICAgICAgICByZXR1cm4gaXNOYU4odGhpc1tUT0tFTl9UWVBFX0lEXSk7XG4gICAgICAgfVxuICAgICAgIGlzVGV4dCgpIHtcbiAgICAgICAgICAgcmV0dXJuIGlzVGV4dFRva2VuKHRoaXMpO1xuICAgICAgIH1cbiAgICAgICBpc1RhZygpIHtcbiAgICAgICAgICAgcmV0dXJuIGlzVGFnVG9rZW4odGhpcyk7XG4gICAgICAgfVxuICAgICAgIGlzQXR0ck5hbWUoKSB7XG4gICAgICAgICAgIHJldHVybiBpc0F0dHJOYW1lVG9rZW4odGhpcyk7XG4gICAgICAgfVxuICAgICAgIGlzQXR0clZhbHVlKCkge1xuICAgICAgICAgICByZXR1cm4gaXNBdHRyVmFsdWVUb2tlbih0aGlzKTtcbiAgICAgICB9XG4gICAgICAgaXNTdGFydCgpIHtcbiAgICAgICAgICAgcmV0dXJuIGlzVGFnU3RhcnQodGhpcyk7XG4gICAgICAgfVxuICAgICAgIGlzRW5kKCkge1xuICAgICAgICAgICByZXR1cm4gaXNUYWdFbmQodGhpcyk7XG4gICAgICAgfVxuICAgICAgIGdldE5hbWUoKSB7XG4gICAgICAgICAgIHJldHVybiBnZXRUYWdOYW1lKHRoaXMpO1xuICAgICAgIH1cbiAgICAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgICAgcmV0dXJuIGdldFRva2VuVmFsdWUodGhpcyk7XG4gICAgICAgfVxuICAgICAgIGdldExpbmUoKSB7XG4gICAgICAgICAgIHJldHVybiBnZXRUb2tlbkxpbmUodGhpcyk7XG4gICAgICAgfVxuICAgICAgIGdldENvbHVtbigpIHtcbiAgICAgICAgICAgcmV0dXJuIGdldFRva2VuQ29sdW1uKHRoaXMpO1xuICAgICAgIH1cbiAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRUYWdUb1RleHQodGhpcyk7XG4gICAgICAgfVxuICAgICAgIC8qKlxuICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgICogQHBhcmFtIGxpbmVcbiAgICAgICogQHBhcmFtIHJvd1xuICAgICAgKi8gY29uc3RydWN0b3IodHlwZSwgdmFsdWUsIGxpbmUsIHJvdyl7XG4gICAgICAgICAgIHRoaXNbVE9LRU5fVFlQRV9JRF0gPSBOdW1iZXIodHlwZSk7XG4gICAgICAgICAgIHRoaXNbVE9LRU5fVkFMVUVfSURdID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgdGhpc1tUT0tFTl9MSU5FX0lEXSA9IE51bWJlcihsaW5lKTtcbiAgICAgICAgICAgdGhpc1tUT0tFTl9DT0xVTU5fSURdID0gTnVtYmVyKHJvdyk7XG4gICAgICAgfVxuICAgfVxuICAgY29uc3QgVFlQRV9XT1JEID0gVE9LRU5fVFlQRV9XT1JEO1xuICAgY29uc3QgVFlQRV9UQUcgPSBUT0tFTl9UWVBFX1RBRztcbiAgIGNvbnN0IFRZUEVfQVRUUl9OQU1FID0gVE9LRU5fVFlQRV9BVFRSX05BTUU7XG4gICBjb25zdCBUWVBFX0FUVFJfVkFMVUUgPSBUT0tFTl9UWVBFX0FUVFJfVkFMVUU7XG4gICBjb25zdCBUWVBFX1NQQUNFID0gVE9LRU5fVFlQRV9TUEFDRTtcbiAgIGNvbnN0IFRZUEVfTkVXX0xJTkUgPSBUT0tFTl9UWVBFX05FV19MSU5FO1xuXG4gICBmdW5jdGlvbiBDaGFyR3JhYmJlcihzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICBjb25zdCBjdXJzb3IgPSB7XG4gICAgICAgICAgIHBvczogMCxcbiAgICAgICAgICAgbGVuOiBzb3VyY2UubGVuZ3RoXG4gICAgICAgfTtcbiAgICAgICBjb25zdCBzdWJzdHJVbnRpbENoYXIgPSAoY2hhcik9PntcbiAgICAgICAgICAgY29uc3QgeyBwb3MgIH0gPSBjdXJzb3I7XG4gICAgICAgICAgIGNvbnN0IGlkeCA9IHNvdXJjZS5pbmRleE9mKGNoYXIsIHBvcyk7XG4gICAgICAgICAgIHJldHVybiBpZHggPj0gMCA/IHNvdXJjZS5zdWJzdHJpbmcocG9zLCBpZHgpIDogJyc7XG4gICAgICAgfTtcbiAgICAgICBjb25zdCBpbmNsdWRlcyA9ICh2YWwpPT5zb3VyY2UuaW5kZXhPZih2YWwsIGN1cnNvci5wb3MpID49IDA7XG4gICAgICAgY29uc3QgaGFzTmV4dCA9ICgpPT5jdXJzb3IubGVuID4gY3Vyc29yLnBvcztcbiAgICAgICBjb25zdCBpc0xhc3QgPSAoKT0+Y3Vyc29yLnBvcyA9PT0gY3Vyc29yLmxlbjtcbiAgICAgICBjb25zdCBza2lwID0gKG51bSA9IDEsIHNpbGVudCk9PntcbiAgICAgICAgICAgY3Vyc29yLnBvcyArPSBudW07XG4gICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMub25Ta2lwICYmICFzaWxlbnQpIHtcbiAgICAgICAgICAgICAgIG9wdGlvbnMub25Ta2lwKCk7XG4gICAgICAgICAgIH1cbiAgICAgICB9O1xuICAgICAgIGNvbnN0IHJlc3QgPSAoKT0+c291cmNlLnN1YnN0cmluZyhjdXJzb3IucG9zKTtcbiAgICAgICBjb25zdCBncmFiTiA9IChudW0gPSAwKT0+c291cmNlLnN1YnN0cmluZyhjdXJzb3IucG9zLCBjdXJzb3IucG9zICsgbnVtKTtcbiAgICAgICBjb25zdCBjdXJyID0gKCk9PnNvdXJjZVtjdXJzb3IucG9zXTtcbiAgICAgICBjb25zdCBwcmV2ID0gKCk9PntcbiAgICAgICAgICAgY29uc3QgcHJldlBvcyA9IGN1cnNvci5wb3MgLSAxO1xuICAgICAgICAgICByZXR1cm4gdHlwZW9mIHNvdXJjZVtwcmV2UG9zXSAhPT0gJ3VuZGVmaW5lZCcgPyBzb3VyY2VbcHJldlBvc10gOiBudWxsO1xuICAgICAgIH07XG4gICAgICAgY29uc3QgbmV4dCA9ICgpPT57XG4gICAgICAgICAgIGNvbnN0IG5leHRQb3MgPSBjdXJzb3IucG9zICsgMTtcbiAgICAgICAgICAgcmV0dXJuIG5leHRQb3MgPD0gc291cmNlLmxlbmd0aCAtIDEgPyBzb3VyY2VbbmV4dFBvc10gOiBudWxsO1xuICAgICAgIH07XG4gICAgICAgY29uc3QgZ3JhYldoaWxlID0gKGNvbmQsIHNpbGVudCk9PntcbiAgICAgICAgICAgbGV0IHN0YXJ0ID0gMDtcbiAgICAgICAgICAgaWYgKGhhc05leHQoKSkge1xuICAgICAgICAgICAgICAgc3RhcnQgPSBjdXJzb3IucG9zO1xuICAgICAgICAgICAgICAgd2hpbGUoaGFzTmV4dCgpICYmIGNvbmQoY3VycigpKSl7XG4gICAgICAgICAgICAgICAgICAgc2tpcCgxLCBzaWxlbnQpO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICB9XG4gICAgICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic3RyaW5nKHN0YXJ0LCBjdXJzb3IucG9zKTtcbiAgICAgICB9O1xuICAgICAgIC8qKlxuICAgICAgKiBAdHlwZSB7c2tpcH1cbiAgICAgICovIHRoaXMuc2tpcCA9IHNraXA7XG4gICAgICAgLyoqXG4gICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgKi8gdGhpcy5oYXNOZXh0ID0gaGFzTmV4dDtcbiAgICAgICAvKipcbiAgICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgICovIHRoaXMuZ2V0Q3VyciA9IGN1cnI7XG4gICAgICAgLyoqXG4gICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICAqLyB0aGlzLmdldFJlc3QgPSByZXN0O1xuICAgICAgIC8qKlxuICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAgKi8gdGhpcy5nZXROZXh0ID0gbmV4dDtcbiAgICAgICAvKipcbiAgICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgICovIHRoaXMuZ2V0UHJldiA9IHByZXY7XG4gICAgICAgLyoqXG4gICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgKi8gdGhpcy5pc0xhc3QgPSBpc0xhc3Q7XG4gICAgICAgLyoqXG4gICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgKi8gdGhpcy5pbmNsdWRlcyA9IGluY2x1ZGVzO1xuICAgICAgIC8qKlxuICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25kXG4gICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50XG4gICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgICovIHRoaXMuZ3JhYldoaWxlID0gZ3JhYldoaWxlO1xuICAgICAgIC8qKlxuICAgICAgKiBAcGFyYW0ge051bWJlcn0gbnVtXG4gICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgICovIHRoaXMuZ3JhYk4gPSBncmFiTjtcbiAgICAgICAvKipcbiAgICAgICogR3JhYnMgcmVzdCBvZiBzdHJpbmcgdW50aWwgaXQgZmluZCBhIGNoYXJcbiAgICAgICogQHBhcmFtIHtTdHJpbmd9IGNoYXJcbiAgICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAgKi8gdGhpcy5zdWJzdHJVbnRpbENoYXIgPSBzdWJzdHJVbnRpbENoYXI7XG4gICB9XG4gICAvKipcbiAgICAqIENyZWF0ZXMgYSBncmFiYmVyIHdyYXBwZXIgZm9yIHNvdXJjZSBzdHJpbmcsIHRoYXQgaGVscHMgdG8gaXRlcmF0ZSBvdmVyIHN0cmluZyBjaGFyIGJ5IGNoYXJcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBzb3VyY2VcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLm9uU2tpcFxuICAgICogQHJldHVybiBDaGFyR3JhYmJlclxuICAgICovIGNvbnN0IGNyZWF0ZUNoYXJHcmFiYmVyID0gKHNvdXJjZSwgb3B0aW9ucyk9Pm5ldyBDaGFyR3JhYmJlcihzb3VyY2UsIG9wdGlvbnMpO1xuICAgLyoqXG4gICAgKiBUcmltcyBzdHJpbmcgZnJvbSBzdGFydCBhbmQgZW5kIGJ5IGNoYXJcbiAgICAqIEBleGFtcGxlXG4gICAgKiAgdHJpbUNoYXIoJypoZWxsbyonLCAnKicpID09PiAnaGVsbG8nXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gY2hhclRvUmVtb3ZlXG4gICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICovIGNvbnN0IHRyaW1DaGFyID0gKHN0ciwgY2hhclRvUmVtb3ZlKT0+e1xuICAgICAgIHdoaWxlKHN0ci5jaGFyQXQoMCkgPT09IGNoYXJUb1JlbW92ZSl7XG4gICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDEpO1xuICAgICAgIH1cbiAgICAgICB3aGlsZShzdHIuY2hhckF0KHN0ci5sZW5ndGggLSAxKSA9PT0gY2hhclRvUmVtb3ZlKXtcbiAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDEpO1xuICAgICAgIH1cbiAgICAgICByZXR1cm4gc3RyO1xuICAgfTtcbiAgIC8qKlxuICAgICogVW5xdW90ZXMgXFxcIiB0byBcIlxuICAgICogQHBhcmFtIHN0clxuICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICovIGNvbnN0IHVucXVvdGUgPSAoc3RyKT0+c3RyLnJlcGxhY2UocGx1Z2luSGVscGVyLkJBQ0tTTEFTSCArIHBsdWdpbkhlbHBlci5RVU9URU1BUkssIHBsdWdpbkhlbHBlci5RVU9URU1BUkspO1xuICAgZnVuY3Rpb24gTm9kZUxpc3QodmFsdWVzID0gW10pIHtcbiAgICAgICBjb25zdCBub2RlcyA9IHZhbHVlcztcbiAgICAgICBjb25zdCBnZXRMYXN0ID0gKCk9PkFycmF5LmlzQXJyYXkobm9kZXMpICYmIG5vZGVzLmxlbmd0aCA+IDAgJiYgdHlwZW9mIG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdICE9PSAndW5kZWZpbmVkJyA/IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICAgICBjb25zdCBmbHVzaExhc3QgPSAoKT0+bm9kZXMubGVuZ3RoID8gbm9kZXMucG9wKCkgOiBmYWxzZTtcbiAgICAgICBjb25zdCBwdXNoID0gKHZhbHVlKT0+bm9kZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgY29uc3QgdG9BcnJheSA9ICgpPT5ub2RlcztcbiAgICAgICB0aGlzLnB1c2ggPSBwdXNoO1xuICAgICAgIHRoaXMudG9BcnJheSA9IHRvQXJyYXk7XG4gICAgICAgdGhpcy5nZXRMYXN0ID0gZ2V0TGFzdDtcbiAgICAgICB0aGlzLmZsdXNoTGFzdCA9IGZsdXNoTGFzdDtcbiAgIH1cbiAgIC8qKlxuICAgICpcbiAgICAqIEBwYXJhbSB2YWx1ZXNcbiAgICAqIEByZXR1cm4ge05vZGVMaXN0fVxuICAgICovIGNvbnN0IGNyZWF0ZUxpc3QgPSAodmFsdWVzID0gW10pPT5uZXcgTm9kZUxpc3QodmFsdWVzKTtcblxuICAgLy8gZm9yIGNhc2VzIDwhLS0gLS0+XG4gICBjb25zdCBFTSA9ICchJztcbiAgIC8qKlxuICAgICogQ3JlYXRlcyBhIFRva2VuIGVudGl0eSBjbGFzc1xuICAgICogQHBhcmFtIHtOdW1iZXJ9IHR5cGVcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICogQHBhcmFtIHtOdW1iZXJ9IHIgbGluZSBudW1iZXJcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBjbCBjaGFyIG51bWJlciBpbiBsaW5lXG4gICAgKi8gY29uc3QgY3JlYXRlVG9rZW4gPSAodHlwZSwgdmFsdWUsIHIgPSAwLCBjbCA9IDApPT5uZXcgVG9rZW4odHlwZSwgdmFsdWUsIHIsIGNsKTtcbiAgIC8qKlxuICAgICogQHR5cGVkZWYge09iamVjdH0gTGV4ZXJcbiAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHRva2VuaXplXG4gICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBpc1Rva2VuTmVzdGVkXG4gICAgKi8gLyoqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gYnVmZmVyXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5vblRva2VuXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5vcGVuVGFnXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5jbG9zZVRhZ1xuICAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmVuYWJsZUVzY2FwZVRhZ3NcbiAgICAqIEByZXR1cm4ge0xleGVyfVxuICAgICovIGZ1bmN0aW9uIGNyZWF0ZUxleGVyKGJ1ZmZlciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgY29uc3QgU1RBVEVfV09SRCA9IDA7XG4gICAgICAgY29uc3QgU1RBVEVfVEFHID0gMTtcbiAgICAgICBjb25zdCBTVEFURV9UQUdfQVRUUlMgPSAyO1xuICAgICAgIGNvbnN0IFRBR19TVEFURV9OQU1FID0gMDtcbiAgICAgICBjb25zdCBUQUdfU1RBVEVfQVRUUiA9IDE7XG4gICAgICAgY29uc3QgVEFHX1NUQVRFX1ZBTFVFID0gMjtcbiAgICAgICBsZXQgcm93ID0gMDtcbiAgICAgICBsZXQgY29sID0gMDtcbiAgICAgICBsZXQgdG9rZW5JbmRleCA9IC0xO1xuICAgICAgIGxldCBzdGF0ZU1vZGUgPSBTVEFURV9XT1JEO1xuICAgICAgIGxldCB0YWdNb2RlID0gVEFHX1NUQVRFX05BTUU7XG4gICAgICAgbGV0IGNvbnRleHRGcmVlVGFnID0gJyc7XG4gICAgICAgY29uc3QgdG9rZW5zID0gbmV3IEFycmF5KE1hdGguZmxvb3IoYnVmZmVyLmxlbmd0aCkpO1xuICAgICAgIGNvbnN0IG9wZW5UYWcgPSBvcHRpb25zLm9wZW5UYWcgfHwgcGx1Z2luSGVscGVyLk9QRU5fQlJBS0VUO1xuICAgICAgIGNvbnN0IGNsb3NlVGFnID0gb3B0aW9ucy5jbG9zZVRhZyB8fCBwbHVnaW5IZWxwZXIuQ0xPU0VfQlJBS0VUO1xuICAgICAgIGNvbnN0IGVzY2FwZVRhZ3MgPSAhIW9wdGlvbnMuZW5hYmxlRXNjYXBlVGFncztcbiAgICAgICBjb25zdCBjb250ZXh0RnJlZVRhZ3MgPSBvcHRpb25zLmNvbnRleHRGcmVlVGFncyB8fCBbXTtcbiAgICAgICBjb25zdCBvblRva2VuID0gb3B0aW9ucy5vblRva2VuIHx8ICgoKT0+e30pO1xuICAgICAgIGNvbnN0IFJFU0VSVkVEX0NIQVJTID0gW1xuICAgICAgICAgICBjbG9zZVRhZyxcbiAgICAgICAgICAgb3BlblRhZyxcbiAgICAgICAgICAgcGx1Z2luSGVscGVyLlFVT1RFTUFSSyxcbiAgICAgICAgICAgcGx1Z2luSGVscGVyLkJBQ0tTTEFTSCxcbiAgICAgICAgICAgcGx1Z2luSGVscGVyLlNQQUNFLFxuICAgICAgICAgICBwbHVnaW5IZWxwZXIuVEFCLFxuICAgICAgICAgICBwbHVnaW5IZWxwZXIuRVEsXG4gICAgICAgICAgIHBsdWdpbkhlbHBlci5OLFxuICAgICAgICAgICBFTVxuICAgICAgIF07XG4gICAgICAgY29uc3QgTk9UX0NIQVJfVE9LRU5TID0gW1xuICAgICAgICAgICBvcGVuVGFnLFxuICAgICAgICAgICBwbHVnaW5IZWxwZXIuU1BBQ0UsXG4gICAgICAgICAgIHBsdWdpbkhlbHBlci5UQUIsXG4gICAgICAgICAgIHBsdWdpbkhlbHBlci5OXG4gICAgICAgXTtcbiAgICAgICBjb25zdCBXSElURVNQQUNFUyA9IFtcbiAgICAgICAgICAgcGx1Z2luSGVscGVyLlNQQUNFLFxuICAgICAgICAgICBwbHVnaW5IZWxwZXIuVEFCXG4gICAgICAgXTtcbiAgICAgICBjb25zdCBTUEVDSUFMX0NIQVJTID0gW1xuICAgICAgICAgICBwbHVnaW5IZWxwZXIuRVEsXG4gICAgICAgICAgIHBsdWdpbkhlbHBlci5TUEFDRSxcbiAgICAgICAgICAgcGx1Z2luSGVscGVyLlRBQlxuICAgICAgIF07XG4gICAgICAgY29uc3QgaXNDaGFyUmVzZXJ2ZWQgPSAoY2hhcik9PlJFU0VSVkVEX0NIQVJTLmluZGV4T2YoY2hhcikgPj0gMDtcbiAgICAgICBjb25zdCBpc05ld0xpbmUgPSAoY2hhcik9PmNoYXIgPT09IHBsdWdpbkhlbHBlci5OO1xuICAgICAgIGNvbnN0IGlzV2hpdGVTcGFjZSA9IChjaGFyKT0+V0hJVEVTUEFDRVMuaW5kZXhPZihjaGFyKSA+PSAwO1xuICAgICAgIGNvbnN0IGlzQ2hhclRva2VuID0gKGNoYXIpPT5OT1RfQ0hBUl9UT0tFTlMuaW5kZXhPZihjaGFyKSA9PT0gLTE7XG4gICAgICAgY29uc3QgaXNTcGVjaWFsQ2hhciA9IChjaGFyKT0+U1BFQ0lBTF9DSEFSUy5pbmRleE9mKGNoYXIpID49IDA7XG4gICAgICAgY29uc3QgaXNFc2NhcGFibGVDaGFyID0gKGNoYXIpPT5jaGFyID09PSBvcGVuVGFnIHx8IGNoYXIgPT09IGNsb3NlVGFnIHx8IGNoYXIgPT09IHBsdWdpbkhlbHBlci5CQUNLU0xBU0g7XG4gICAgICAgY29uc3QgaXNFc2NhcGVDaGFyID0gKGNoYXIpPT5jaGFyID09PSBwbHVnaW5IZWxwZXIuQkFDS1NMQVNIO1xuICAgICAgIGNvbnN0IG9uU2tpcCA9ICgpPT57XG4gICAgICAgICAgIGNvbCsrO1xuICAgICAgIH07XG4gICAgICAgY29uc3QgdW5xID0gKHZhbCk9PnVucXVvdGUodHJpbUNoYXIodmFsLCBwbHVnaW5IZWxwZXIuUVVPVEVNQVJLKSk7XG4gICAgICAgY29uc3QgY2hlY2tDb250ZXh0RnJlZU1vZGUgPSAobmFtZSwgaXNDbG9zaW5nVGFnKT0+e1xuICAgICAgICAgICBpZiAoY29udGV4dEZyZWVUYWcgIT09ICcnICYmIGlzQ2xvc2luZ1RhZykge1xuICAgICAgICAgICAgICAgY29udGV4dEZyZWVUYWcgPSAnJztcbiAgICAgICAgICAgfVxuICAgICAgICAgICBpZiAoY29udGV4dEZyZWVUYWcgPT09ICcnICYmIGNvbnRleHRGcmVlVGFncy5pbmNsdWRlcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgY29udGV4dEZyZWVUYWcgPSBuYW1lO1xuICAgICAgICAgICB9XG4gICAgICAgfTtcbiAgICAgICBjb25zdCBjaGFycyA9IGNyZWF0ZUNoYXJHcmFiYmVyKGJ1ZmZlciwge1xuICAgICAgICAgICBvblNraXBcbiAgICAgICB9KTtcbiAgICAgICAvKipcbiAgICAgICogRW1pdHMgbmV3bHkgY3JlYXRlZCB0b2tlbiB0byBzdWJzY3JpYmVyXG4gICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlXG4gICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAgKi8gZnVuY3Rpb24gZW1pdFRva2VuKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgICAgIGNvbnN0IHRva2VuID0gY3JlYXRlVG9rZW4odHlwZSwgdmFsdWUsIHJvdywgY29sKTtcbiAgICAgICAgICAgb25Ub2tlbih0b2tlbik7XG4gICAgICAgICAgIHRva2VuSW5kZXggKz0gMTtcbiAgICAgICAgICAgdG9rZW5zW3Rva2VuSW5kZXhdID0gdG9rZW47XG4gICAgICAgfVxuICAgICAgIGZ1bmN0aW9uIG5leHRUYWdTdGF0ZSh0YWdDaGFycywgaXNTaW5nbGVWYWx1ZVRhZykge1xuICAgICAgICAgICBpZiAodGFnTW9kZSA9PT0gVEFHX1NUQVRFX0FUVFIpIHtcbiAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkQXR0ck5hbWUgPSAoY2hhcik9PiEoY2hhciA9PT0gcGx1Z2luSGVscGVyLkVRIHx8IGlzV2hpdGVTcGFjZShjaGFyKSk7XG4gICAgICAgICAgICAgICBjb25zdCBuYW1lID0gdGFnQ2hhcnMuZ3JhYldoaWxlKHZhbGlkQXR0ck5hbWUpO1xuICAgICAgICAgICAgICAgY29uc3QgaXNFbmQgPSB0YWdDaGFycy5pc0xhc3QoKTtcbiAgICAgICAgICAgICAgIGNvbnN0IGlzVmFsdWUgPSB0YWdDaGFycy5nZXRDdXJyKCkgIT09IHBsdWdpbkhlbHBlci5FUTtcbiAgICAgICAgICAgICAgIHRhZ0NoYXJzLnNraXAoKTtcbiAgICAgICAgICAgICAgIGlmIChpc0VuZCB8fCBpc1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgZW1pdFRva2VuKFRZUEVfQVRUUl9WQUxVRSwgdW5xKG5hbWUpKTtcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgZW1pdFRva2VuKFRZUEVfQVRUUl9OQU1FLCBuYW1lKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGlmIChpc0VuZCkge1xuICAgICAgICAgICAgICAgICAgIHJldHVybiBUQUdfU1RBVEVfTkFNRTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGlmIChpc1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIFRBR19TVEFURV9BVFRSO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgcmV0dXJuIFRBR19TVEFURV9WQUxVRTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICBpZiAodGFnTW9kZSA9PT0gVEFHX1NUQVRFX1ZBTFVFKSB7XG4gICAgICAgICAgICAgICBsZXQgc3RhdGVTcGVjaWFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICBjb25zdCB2YWxpZEF0dHJWYWx1ZSA9IChjaGFyKT0+e1xuICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0IGlzRVEgPSBjaGFyID09PSBFUTtcbiAgICAgICAgICAgICAgICAgICBjb25zdCBpc1FNID0gY2hhciA9PT0gcGx1Z2luSGVscGVyLlFVT1RFTUFSSztcbiAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2Q2hhciA9IHRhZ0NoYXJzLmdldFByZXYoKTtcbiAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hhciA9IHRhZ0NoYXJzLmdldE5leHQoKTtcbiAgICAgICAgICAgICAgICAgICBjb25zdCBpc1ByZXZTTEFTSCA9IHByZXZDaGFyID09PSBwbHVnaW5IZWxwZXIuQkFDS1NMQVNIO1xuICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzTmV4dEVRID0gbmV4dENoYXIgPT09IHBsdWdpbkhlbHBlci5FUTtcbiAgICAgICAgICAgICAgICAgICBjb25zdCBpc1dTID0gaXNXaGl0ZVNwYWNlKGNoYXIpO1xuICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0IGlzUHJldldTID0gaXNXaGl0ZVNwYWNlKHByZXZDaGFyKTtcbiAgICAgICAgICAgICAgICAgICBjb25zdCBpc05leHRXUyA9IGlzV2hpdGVTcGFjZShuZXh0Q2hhcik7XG4gICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlU3BlY2lhbCAmJiBpc1NwZWNpYWxDaGFyKGNoYXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICBpZiAoaXNRTSAmJiAhaXNQcmV2U0xBU0gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVTcGVjaWFsID0gIXN0YXRlU3BlY2lhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0ZVNwZWNpYWwgJiYgIShpc05leHRFUSB8fCBpc05leHRXUykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICBpZiAoIWlzU2luZ2xlVmFsdWVUYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzV1MgPT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiAoaXNFUSB8fCBpc1dTKSA9PT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgIGNvbnN0IG5hbWUxID0gdGFnQ2hhcnMuZ3JhYldoaWxlKHZhbGlkQXR0clZhbHVlKTtcbiAgICAgICAgICAgICAgIHRhZ0NoYXJzLnNraXAoKTtcbiAgICAgICAgICAgICAgIGVtaXRUb2tlbihUWVBFX0FUVFJfVkFMVUUsIHVucShuYW1lMSkpO1xuICAgICAgICAgICAgICAgaWYgKHRhZ0NoYXJzLmlzTGFzdCgpKSB7XG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIFRBR19TVEFURV9OQU1FO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgcmV0dXJuIFRBR19TVEFURV9BVFRSO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIGNvbnN0IHZhbGlkTmFtZSA9IChjaGFyKT0+IShjaGFyID09PSBwbHVnaW5IZWxwZXIuRVEgfHwgaXNXaGl0ZVNwYWNlKGNoYXIpIHx8IHRhZ0NoYXJzLmlzTGFzdCgpKTtcbiAgICAgICAgICAgY29uc3QgbmFtZTIgPSB0YWdDaGFycy5ncmFiV2hpbGUodmFsaWROYW1lKTtcbiAgICAgICAgICAgZW1pdFRva2VuKFRZUEVfVEFHLCBuYW1lMik7XG4gICAgICAgICAgIGNoZWNrQ29udGV4dEZyZWVNb2RlKG5hbWUyKTtcbiAgICAgICAgICAgdGFnQ2hhcnMuc2tpcCgpO1xuICAgICAgICAgICAvLyBpbiBjYXNlcyB3aGVuIHdlIGhhcyBbdXJsPXNvbWV2YWxdR0VUWy91cmxdIGFuZCB3ZSBkb250IG5lZWQgdG8gcGFyc2UgYWxsXG4gICAgICAgICAgIGlmIChpc1NpbmdsZVZhbHVlVGFnKSB7XG4gICAgICAgICAgICAgICByZXR1cm4gVEFHX1NUQVRFX1ZBTFVFO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIGNvbnN0IGhhc0VRID0gdGFnQ2hhcnMuaW5jbHVkZXMocGx1Z2luSGVscGVyLkVRKTtcbiAgICAgICAgICAgcmV0dXJuIGhhc0VRID8gVEFHX1NUQVRFX0FUVFIgOiBUQUdfU1RBVEVfVkFMVUU7XG4gICAgICAgfVxuICAgICAgIGZ1bmN0aW9uIHN0YXRlVGFnKCkge1xuICAgICAgICAgICBjb25zdCBjdXJyQ2hhciA9IGNoYXJzLmdldEN1cnIoKTtcbiAgICAgICAgICAgY29uc3QgbmV4dENoYXIgPSBjaGFycy5nZXROZXh0KCk7XG4gICAgICAgICAgIGNoYXJzLnNraXAoKTtcbiAgICAgICAgICAgLy8gZGV0ZWN0IGNhc2Ugd2hlcmUgd2UgaGF2ZSAnW015IHdvcmQgW3RhZ11bL3RhZ10nIG9yIHdlIGhhdmUgJ1tNeSBsYXN0IGxpbmUgd29yZCdcbiAgICAgICAgICAgY29uc3Qgc3Vic3RyID0gY2hhcnMuc3Vic3RyVW50aWxDaGFyKGNsb3NlVGFnKTtcbiAgICAgICAgICAgY29uc3QgaGFzSW52YWxpZENoYXJzID0gc3Vic3RyLmxlbmd0aCA9PT0gMCB8fCBzdWJzdHIuaW5kZXhPZihvcGVuVGFnKSA+PSAwO1xuICAgICAgICAgICBpZiAoaXNDaGFyUmVzZXJ2ZWQobmV4dENoYXIpIHx8IGhhc0ludmFsaWRDaGFycyB8fCBjaGFycy5pc0xhc3QoKSkge1xuICAgICAgICAgICAgICAgZW1pdFRva2VuKFRZUEVfV09SRCwgY3VyckNoYXIpO1xuICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1dPUkQ7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgLy8gW215VGFnICAgXVxuICAgICAgICAgICBjb25zdCBpc05vQXR0cnNJblRhZyA9IHN1YnN0ci5pbmRleE9mKHBsdWdpbkhlbHBlci5FUSkgPT09IC0xO1xuICAgICAgICAgICAvLyBbL215VGFnXVxuICAgICAgICAgICBjb25zdCBpc0Nsb3NpbmdUYWcgPSBzdWJzdHJbMF0gPT09IHBsdWdpbkhlbHBlci5TTEFTSDtcbiAgICAgICAgICAgaWYgKGlzTm9BdHRyc0luVGFnIHx8IGlzQ2xvc2luZ1RhZykge1xuICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNoYXJzLmdyYWJXaGlsZSgoY2hhcik9PmNoYXIgIT09IGNsb3NlVGFnKTtcbiAgICAgICAgICAgICAgIGNoYXJzLnNraXAoKTsgLy8gc2tpcCBjbG9zZVRhZ1xuICAgICAgICAgICAgICAgZW1pdFRva2VuKFRZUEVfVEFHLCBuYW1lKTtcbiAgICAgICAgICAgICAgIGNoZWNrQ29udGV4dEZyZWVNb2RlKG5hbWUsIGlzQ2xvc2luZ1RhZyk7XG4gICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfV09SRDtcbiAgICAgICAgICAgfVxuICAgICAgICAgICByZXR1cm4gU1RBVEVfVEFHX0FUVFJTO1xuICAgICAgIH1cbiAgICAgICBmdW5jdGlvbiBzdGF0ZUF0dHJzKCkge1xuICAgICAgICAgICBjb25zdCBzaWxlbnQgPSB0cnVlO1xuICAgICAgICAgICBjb25zdCB0YWdTdHIgPSBjaGFycy5ncmFiV2hpbGUoKGNoYXIpPT5jaGFyICE9PSBjbG9zZVRhZywgc2lsZW50KTtcbiAgICAgICAgICAgY29uc3QgdGFnR3JhYmJlciA9IGNyZWF0ZUNoYXJHcmFiYmVyKHRhZ1N0ciwge1xuICAgICAgICAgICAgICAgb25Ta2lwXG4gICAgICAgICAgIH0pO1xuICAgICAgICAgICBjb25zdCBoYXNTcGFjZSA9IHRhZ0dyYWJiZXIuaW5jbHVkZXMocGx1Z2luSGVscGVyLlNQQUNFKTtcbiAgICAgICAgICAgdGFnTW9kZSA9IFRBR19TVEFURV9OQU1FO1xuICAgICAgICAgICB3aGlsZSh0YWdHcmFiYmVyLmhhc05leHQoKSl7XG4gICAgICAgICAgICAgICB0YWdNb2RlID0gbmV4dFRhZ1N0YXRlKHRhZ0dyYWJiZXIsICFoYXNTcGFjZSk7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgY2hhcnMuc2tpcCgpOyAvLyBza2lwIGNsb3NlVGFnXG4gICAgICAgICAgIHJldHVybiBTVEFURV9XT1JEO1xuICAgICAgIH1cbiAgICAgICBmdW5jdGlvbiBzdGF0ZVdvcmQoKSB7XG4gICAgICAgICAgIGlmIChpc05ld0xpbmUoY2hhcnMuZ2V0Q3VycigpKSkge1xuICAgICAgICAgICAgICAgZW1pdFRva2VuKFRZUEVfTkVXX0xJTkUsIGNoYXJzLmdldEN1cnIoKSk7XG4gICAgICAgICAgICAgICBjaGFycy5za2lwKCk7XG4gICAgICAgICAgICAgICBjb2wgPSAwO1xuICAgICAgICAgICAgICAgcm93Kys7XG4gICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfV09SRDtcbiAgICAgICAgICAgfVxuICAgICAgICAgICBpZiAoaXNXaGl0ZVNwYWNlKGNoYXJzLmdldEN1cnIoKSkpIHtcbiAgICAgICAgICAgICAgIGNvbnN0IHdvcmQgPSBjaGFycy5ncmFiV2hpbGUoaXNXaGl0ZVNwYWNlKTtcbiAgICAgICAgICAgICAgIGVtaXRUb2tlbihUWVBFX1NQQUNFLCB3b3JkKTtcbiAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9XT1JEO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIGlmIChjaGFycy5nZXRDdXJyKCkgPT09IG9wZW5UYWcpIHtcbiAgICAgICAgICAgICAgIGlmIChjb250ZXh0RnJlZVRhZykge1xuICAgICAgICAgICAgICAgICAgIGNvbnN0IGZ1bGxUYWdMZW4gPSBvcGVuVGFnLmxlbmd0aCArIHBsdWdpbkhlbHBlci5TTEFTSC5sZW5ndGggKyBjb250ZXh0RnJlZVRhZy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgY29uc3QgZnVsbFRhZ05hbWUgPSBgJHtvcGVuVGFnfSR7cGx1Z2luSGVscGVyLlNMQVNIfSR7Y29udGV4dEZyZWVUYWd9YDtcbiAgICAgICAgICAgICAgICAgICBjb25zdCBmb3VuZFRhZyA9IGNoYXJzLmdyYWJOKGZ1bGxUYWdMZW4pO1xuICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzRW5kQ29udGV4dEZyZWVNb2RlID0gZm91bmRUYWcgPT09IGZ1bGxUYWdOYW1lO1xuICAgICAgICAgICAgICAgICAgIGlmIChpc0VuZENvbnRleHRGcmVlTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfVEFHO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhcnMuaW5jbHVkZXMoY2xvc2VUYWcpKSB7XG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1RBRztcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGVtaXRUb2tlbihUWVBFX1dPUkQsIGNoYXJzLmdldEN1cnIoKSk7XG4gICAgICAgICAgICAgICBjaGFycy5za2lwKCk7XG4gICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfV09SRDtcbiAgICAgICAgICAgfVxuICAgICAgICAgICBpZiAoZXNjYXBlVGFncykge1xuICAgICAgICAgICAgICAgaWYgKGlzRXNjYXBlQ2hhcihjaGFycy5nZXRDdXJyKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgY29uc3QgY3VyckNoYXIgPSBjaGFycy5nZXRDdXJyKCk7XG4gICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dENoYXIgPSBjaGFycy5nZXROZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgY2hhcnMuc2tpcCgpOyAvLyBza2lwIHRoZSBcXCB3aXRob3V0IGVtaXR0aW5nIGFueXRoaW5nXG4gICAgICAgICAgICAgICAgICAgaWYgKGlzRXNjYXBhYmxlQ2hhcihuZXh0Q2hhcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgY2hhcnMuc2tpcCgpOyAvLyBza2lwIHBhc3QgdGhlIFssIF0gb3IgXFwgYXMgd2VsbFxuICAgICAgICAgICAgICAgICAgICAgICBlbWl0VG9rZW4oVFlQRV9XT1JELCBuZXh0Q2hhcik7XG4gICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9XT1JEO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICBlbWl0VG9rZW4oVFlQRV9XT1JELCBjdXJyQ2hhcik7XG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1dPUkQ7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICBjb25zdCBpc0NoYXIgPSAoY2hhcik9PmlzQ2hhclRva2VuKGNoYXIpICYmICFpc0VzY2FwZUNoYXIoY2hhcik7XG4gICAgICAgICAgICAgICBjb25zdCB3b3JkMSA9IGNoYXJzLmdyYWJXaGlsZShpc0NoYXIpO1xuICAgICAgICAgICAgICAgZW1pdFRva2VuKFRZUEVfV09SRCwgd29yZDEpO1xuICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1dPUkQ7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgY29uc3Qgd29yZDIgPSBjaGFycy5ncmFiV2hpbGUoaXNDaGFyVG9rZW4pO1xuICAgICAgICAgICBlbWl0VG9rZW4oVFlQRV9XT1JELCB3b3JkMik7XG4gICAgICAgICAgIHJldHVybiBTVEFURV9XT1JEO1xuICAgICAgIH1cbiAgICAgICBmdW5jdGlvbiB0b2tlbml6ZSgpIHtcbiAgICAgICAgICAgc3RhdGVNb2RlID0gU1RBVEVfV09SRDtcbiAgICAgICAgICAgd2hpbGUoY2hhcnMuaGFzTmV4dCgpKXtcbiAgICAgICAgICAgICAgIHN3aXRjaChzdGF0ZU1vZGUpe1xuICAgICAgICAgICAgICAgICAgIGNhc2UgU1RBVEVfVEFHOlxuICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZU1vZGUgPSBzdGF0ZVRhZygpO1xuICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICBjYXNlIFNUQVRFX1RBR19BVFRSUzpcbiAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVNb2RlID0gc3RhdGVBdHRycygpO1xuICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICBjYXNlIFNUQVRFX1dPUkQ6XG4gICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVNb2RlID0gc3RhdGVXb3JkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICB9XG4gICAgICAgICAgIHRva2Vucy5sZW5ndGggPSB0b2tlbkluZGV4ICsgMTtcbiAgICAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgICB9XG4gICAgICAgZnVuY3Rpb24gaXNUb2tlbk5lc3RlZCh0b2tlbikge1xuICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9wZW5UYWcgKyBwbHVnaW5IZWxwZXIuU0xBU0ggKyB0b2tlbi5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAvLyBwb3RlbnRpYWwgYm90dGxlbmVja1xuICAgICAgICAgICByZXR1cm4gYnVmZmVyLmluZGV4T2YodmFsdWUpID4gLTE7XG4gICAgICAgfVxuICAgICAgIHJldHVybiB7XG4gICAgICAgICAgIHRva2VuaXplLFxuICAgICAgICAgICBpc1Rva2VuTmVzdGVkXG4gICAgICAgfTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBAcHVibGljXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRzLmNyZWF0ZVRva2VuaXplclxuICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBvcHRzLm9ubHlBbGxvd1RhZ3NcbiAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gb3B0cy5jb250ZXh0RnJlZVRhZ3NcbiAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0cy5lbmFibGVFc2NhcGVUYWdzXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vcGVuVGFnXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5jbG9zZVRhZ1xuICAgICogQHJldHVybiB7QXJyYXk8c3RyaW5nfFRhZ05vZGU+fVxuICAgICovIGNvbnN0IHBhcnNlID0gKGlucHV0LCBvcHRzID0ge30pPT57XG4gICAgICAgY29uc3Qgb3B0aW9ucyA9IG9wdHM7XG4gICAgICAgY29uc3Qgb3BlblRhZyA9IG9wdGlvbnMub3BlblRhZyB8fCBwbHVnaW5IZWxwZXIuT1BFTl9CUkFLRVQ7XG4gICAgICAgY29uc3QgY2xvc2VUYWcgPSBvcHRpb25zLmNsb3NlVGFnIHx8IHBsdWdpbkhlbHBlci5DTE9TRV9CUkFLRVQ7XG4gICAgICAgY29uc3Qgb25seUFsbG93VGFncyA9IChvcHRpb25zLm9ubHlBbGxvd1RhZ3MgfHwgW10pLmZpbHRlcihCb29sZWFuKS5tYXAoKHRhZyk9PnRhZy50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICBsZXQgdG9rZW5pemVyID0gbnVsbDtcbiAgICAgICAvKipcbiAgICAgICogUmVzdWx0IEFTVCBvZiBub2Rlc1xuICAgICAgKiBAcHJpdmF0ZVxuICAgICAgKiBAdHlwZSB7Tm9kZUxpc3R9XG4gICAgICAqLyBjb25zdCBub2RlcyA9IGNyZWF0ZUxpc3QoKTtcbiAgICAgICAvKipcbiAgICAgICogVGVtcCBidWZmZXIgb2Ygbm9kZXMgdGhhdCdzIG5lc3RlZCB0byBhbm90aGVyIG5vZGVcbiAgICAgICogQHByaXZhdGVcbiAgICAgICogQHR5cGUge05vZGVMaXN0fVxuICAgICAgKi8gY29uc3QgbmVzdGVkTm9kZXMgPSBjcmVhdGVMaXN0KCk7XG4gICAgICAgLyoqXG4gICAgICAqIFRlbXAgYnVmZmVyIG9mIG5vZGVzIFt0YWcuLl0uLi5bL3RhZ11cbiAgICAgICogQHByaXZhdGVcbiAgICAgICogQHR5cGUge05vZGVMaXN0fVxuICAgICAgKi8gY29uc3QgdGFnTm9kZXMgPSBjcmVhdGVMaXN0KCk7XG4gICAgICAgLyoqXG4gICAgICAqIFRlbXAgYnVmZmVyIG9mIHRhZyBhdHRyaWJ1dGVzXG4gICAgICAqIEBwcml2YXRlXG4gICAgICAqIEB0eXBlIHtOb2RlTGlzdH1cbiAgICAgICovIGNvbnN0IHRhZ05vZGVzQXR0ck5hbWUgPSBjcmVhdGVMaXN0KCk7XG4gICAgICAgLyoqXG4gICAgICAqIENhY2hlIGZvciBuZXN0ZWQgdGFncyBjaGVja3NcbiAgICAgICogQHR5cGUgU2V0PHN0cmluZz5cbiAgICAgICovIGNvbnN0IG5lc3RlZFRhZ3NNYXAgPSBuZXcgU2V0KCk7XG4gICAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7VG9rZW59IHRva2VuXG4gICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgKi8gY29uc3QgaXNUb2tlbk5lc3RlZCA9ICh0b2tlbik9PntcbiAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0b2tlbi5nZXRWYWx1ZSgpO1xuICAgICAgICAgICBpZiAoIW5lc3RlZFRhZ3NNYXAuaGFzKHZhbHVlKSAmJiB0b2tlbml6ZXIuaXNUb2tlbk5lc3RlZCAmJiB0b2tlbml6ZXIuaXNUb2tlbk5lc3RlZCh0b2tlbikpIHtcbiAgICAgICAgICAgICAgIG5lc3RlZFRhZ3NNYXAuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIHJldHVybiBuZXN0ZWRUYWdzTWFwLmhhcyh2YWx1ZSk7XG4gICAgICAgfTtcbiAgICAgICAvKipcbiAgICAgICogQHByaXZhdGVcbiAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWVcbiAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAqLyBjb25zdCBpc1RhZ05lc3RlZCA9ICh0YWdOYW1lKT0+Qm9vbGVhbihuZXN0ZWRUYWdzTWFwLmhhcyh0YWdOYW1lKSk7XG4gICAgICAgLyoqXG4gICAgICAqIEBwcml2YXRlXG4gICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgKi8gY29uc3QgaXNBbGxvd2VkVGFnID0gKHZhbHVlKT0+e1xuICAgICAgICAgICBpZiAob25seUFsbG93VGFncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgIHJldHVybiBvbmx5QWxsb3dUYWdzLmluZGV4T2YodmFsdWUudG9Mb3dlckNhc2UoKSkgPj0gMDtcbiAgICAgICAgICAgfVxuICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICB9O1xuICAgICAgIC8qKlxuICAgICAgKiBGbHVzaGVzIHRlbXAgdGFnIG5vZGVzIGFuZCBpdHMgYXR0cmlidXRlcyBidWZmZXJzXG4gICAgICAqIEBwcml2YXRlXG4gICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAgKi8gY29uc3QgZmx1c2hUYWdOb2RlcyA9ICgpPT57XG4gICAgICAgICAgIGlmICh0YWdOb2Rlcy5mbHVzaExhc3QoKSkge1xuICAgICAgICAgICAgICAgdGFnTm9kZXNBdHRyTmFtZS5mbHVzaExhc3QoKTtcbiAgICAgICAgICAgfVxuICAgICAgIH07XG4gICAgICAgLyoqXG4gICAgICAqIEBwcml2YXRlXG4gICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAgKi8gY29uc3QgZ2V0Tm9kZXMgPSAoKT0+e1xuICAgICAgICAgICBjb25zdCBsYXN0TmVzdGVkTm9kZSA9IG5lc3RlZE5vZGVzLmdldExhc3QoKTtcbiAgICAgICAgICAgaWYgKGxhc3ROZXN0ZWROb2RlICYmIEFycmF5LmlzQXJyYXkobGFzdE5lc3RlZE5vZGUuY29udGVudCkpIHtcbiAgICAgICAgICAgICAgIHJldHVybiBsYXN0TmVzdGVkTm9kZS5jb250ZW50O1xuICAgICAgICAgICB9XG4gICAgICAgICAgIHJldHVybiBub2Rlcy50b0FycmF5KCk7XG4gICAgICAgfTtcbiAgICAgICAvKipcbiAgICAgICogQHByaXZhdGVcbiAgICAgICogQHBhcmFtIHtzdHJpbmd8VGFnTm9kZX0gbm9kZVxuICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTmVzdGVkXG4gICAgICAqLyBjb25zdCBhcHBlbmROb2RlQXNTdHJpbmcgPSAobm9kZSwgaXNOZXN0ZWQgPSB0cnVlKT0+e1xuICAgICAgICAgICBjb25zdCBpdGVtcyA9IGdldE5vZGVzKCk7XG4gICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgICAgaXRlbXMucHVzaChub2RlLnRvVGFnU3RhcnQoe1xuICAgICAgICAgICAgICAgICAgIG9wZW5UYWcsXG4gICAgICAgICAgICAgICAgICAgY2xvc2VUYWdcbiAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgIGlmIChub2RlLmNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgbm9kZS5jb250ZW50LmZvckVhY2goKGl0ZW0pPT57XG4gICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgaWYgKGlzTmVzdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2gobm9kZS50b1RhZ0VuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuVGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VUYWdcbiAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgIH07XG4gICAgICAgLyoqXG4gICAgICAqIEBwcml2YXRlXG4gICAgICAqIEBwYXJhbSB7c3RyaW5nfFRhZ05vZGV9IG5vZGVcbiAgICAgICovIGNvbnN0IGFwcGVuZE5vZGVzID0gKG5vZGUpPT57XG4gICAgICAgICAgIGNvbnN0IGl0ZW1zID0gZ2V0Tm9kZXMoKTtcbiAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICAgICBpZiAocGx1Z2luSGVscGVyLmlzVGFnTm9kZShub2RlKSkge1xuICAgICAgICAgICAgICAgICAgIGlmIChpc0FsbG93ZWRUYWcobm9kZS50YWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2gobm9kZS50b1RhZ05vZGUoKSk7XG4gICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kTm9kZUFzU3RyaW5nKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgIH07XG4gICAgICAgLyoqXG4gICAgICAqIEBwcml2YXRlXG4gICAgICAqIEBwYXJhbSB7VG9rZW59IHRva2VuXG4gICAgICAqLyBjb25zdCBoYW5kbGVUYWdTdGFydCA9ICh0b2tlbik9PntcbiAgICAgICAgICAgZmx1c2hUYWdOb2RlcygpO1xuICAgICAgICAgICBjb25zdCB0YWdOb2RlID0gcGx1Z2luSGVscGVyLlRhZ05vZGUuY3JlYXRlKHRva2VuLmdldFZhbHVlKCkpO1xuICAgICAgICAgICBjb25zdCBpc05lc3RlZCA9IGlzVG9rZW5OZXN0ZWQodG9rZW4pO1xuICAgICAgICAgICB0YWdOb2Rlcy5wdXNoKHRhZ05vZGUpO1xuICAgICAgICAgICBpZiAoaXNOZXN0ZWQpIHtcbiAgICAgICAgICAgICAgIG5lc3RlZE5vZGVzLnB1c2godGFnTm9kZSk7XG4gICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICBhcHBlbmROb2Rlcyh0YWdOb2RlKTtcbiAgICAgICAgICAgfVxuICAgICAgIH07XG4gICAgICAgLyoqXG4gICAgICAqIEBwcml2YXRlXG4gICAgICAqIEBwYXJhbSB7VG9rZW59IHRva2VuXG4gICAgICAqLyBjb25zdCBoYW5kbGVUYWdFbmQgPSAodG9rZW4pPT57XG4gICAgICAgICAgIGZsdXNoVGFnTm9kZXMoKTtcbiAgICAgICAgICAgY29uc3QgbGFzdE5lc3RlZE5vZGUgPSBuZXN0ZWROb2Rlcy5mbHVzaExhc3QoKTtcbiAgICAgICAgICAgaWYgKGxhc3ROZXN0ZWROb2RlKSB7XG4gICAgICAgICAgICAgICBhcHBlbmROb2RlcyhsYXN0TmVzdGVkTm9kZSk7XG4gICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMub25FcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgY29uc3QgdGFnID0gdG9rZW4uZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSB0b2tlbi5nZXRMaW5lKCk7XG4gICAgICAgICAgICAgICBjb25zdCBjb2x1bW4gPSB0b2tlbi5nZXRDb2x1bW4oKTtcbiAgICAgICAgICAgICAgIG9wdGlvbnMub25FcnJvcih7XG4gICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYEluY29uc2lzdGVudCB0YWcgJyR7dGFnfScgb24gbGluZSAke2xpbmV9IGFuZCBjb2x1bW4gJHtjb2x1bW59YCxcbiAgICAgICAgICAgICAgICAgICB0YWdOYW1lOiB0YWcsXG4gICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZSxcbiAgICAgICAgICAgICAgICAgICBjb2x1bW5OdW1iZXI6IGNvbHVtblxuICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgIH1cbiAgICAgICB9O1xuICAgICAgIC8qKlxuICAgICAgKiBAcHJpdmF0ZVxuICAgICAgKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICAgICAgKi8gY29uc3QgaGFuZGxlVGFnID0gKHRva2VuKT0+e1xuICAgICAgICAgICAvLyBbdGFnXVxuICAgICAgICAgICBpZiAodG9rZW4uaXNTdGFydCgpKSB7XG4gICAgICAgICAgICAgICBoYW5kbGVUYWdTdGFydCh0b2tlbik7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgLy8gWy90YWddXG4gICAgICAgICAgIGlmICh0b2tlbi5pc0VuZCgpKSB7XG4gICAgICAgICAgICAgICBoYW5kbGVUYWdFbmQodG9rZW4pO1xuICAgICAgICAgICB9XG4gICAgICAgfTtcbiAgICAgICAvKipcbiAgICAgICogQHByaXZhdGVcbiAgICAgICogQHBhcmFtIHtUb2tlbn0gdG9rZW5cbiAgICAgICovIGNvbnN0IGhhbmRsZU5vZGUgPSAodG9rZW4pPT57XG4gICAgICAgICAgIC8qKlxuICAgICAgICAqIEB0eXBlIHtUYWdOb2RlfVxuICAgICAgICAqLyBjb25zdCBsYXN0VGFnTm9kZSA9IHRhZ05vZGVzLmdldExhc3QoKTtcbiAgICAgICAgICAgY29uc3QgdG9rZW5WYWx1ZSA9IHRva2VuLmdldFZhbHVlKCk7XG4gICAgICAgICAgIGNvbnN0IGlzTmVzdGVkID0gaXNUYWdOZXN0ZWQodG9rZW4pO1xuICAgICAgICAgICBpZiAobGFzdFRhZ05vZGUpIHtcbiAgICAgICAgICAgICAgIGlmICh0b2tlbi5pc0F0dHJOYW1lKCkpIHtcbiAgICAgICAgICAgICAgICAgICB0YWdOb2Rlc0F0dHJOYW1lLnB1c2godG9rZW5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgbGFzdFRhZ05vZGUuYXR0cih0YWdOb2Rlc0F0dHJOYW1lLmdldExhc3QoKSwgJycpO1xuICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbi5pc0F0dHJWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgY29uc3QgYXR0ck5hbWUgPSB0YWdOb2Rlc0F0dHJOYW1lLmdldExhc3QoKTtcbiAgICAgICAgICAgICAgICAgICBpZiAoYXR0ck5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgbGFzdFRhZ05vZGUuYXR0cihhdHRyTmFtZSwgdG9rZW5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgIHRhZ05vZGVzQXR0ck5hbWUuZmx1c2hMYXN0KCk7XG4gICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgbGFzdFRhZ05vZGUuYXR0cih0b2tlblZhbHVlLCB0b2tlblZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuLmlzVGV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgaWYgKGlzTmVzdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIGxhc3RUYWdOb2RlLmFwcGVuZCh0b2tlblZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmROb2Rlcyh0b2tlblZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuLmlzVGFnKCkpIHtcbiAgICAgICAgICAgICAgICAgICAvLyBpZiB0YWcgaXMgbm90IGFsbG93ZWQsIGp1c3QgcGFzdCBpdCBhcyBpc1xuICAgICAgICAgICAgICAgICAgIGFwcGVuZE5vZGVzKHRva2VuLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuLmlzVGV4dCgpKSB7XG4gICAgICAgICAgICAgICBhcHBlbmROb2Rlcyh0b2tlblZhbHVlKTtcbiAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbi5pc1RhZygpKSB7XG4gICAgICAgICAgICAgICAvLyBpZiB0YWcgaXMgbm90IGFsbG93ZWQsIGp1c3QgcGFzdCBpdCBhcyBpc1xuICAgICAgICAgICAgICAgYXBwZW5kTm9kZXModG9rZW4udG9TdHJpbmcoKSk7XG4gICAgICAgICAgIH1cbiAgICAgICB9O1xuICAgICAgIC8qKlxuICAgICAgKiBAcHJpdmF0ZVxuICAgICAgKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICAgICAgKi8gY29uc3Qgb25Ub2tlbiA9ICh0b2tlbik9PntcbiAgICAgICAgICAgaWYgKHRva2VuLmlzVGFnKCkpIHtcbiAgICAgICAgICAgICAgIGhhbmRsZVRhZyh0b2tlbik7XG4gICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICBoYW5kbGVOb2RlKHRva2VuKTtcbiAgICAgICAgICAgfVxuICAgICAgIH07XG4gICAgICAgdG9rZW5pemVyID0gKG9wdHMuY3JlYXRlVG9rZW5pemVyID8gb3B0cy5jcmVhdGVUb2tlbml6ZXIgOiBjcmVhdGVMZXhlcikoaW5wdXQsIHtcbiAgICAgICAgICAgb25Ub2tlbixcbiAgICAgICAgICAgb3BlblRhZyxcbiAgICAgICAgICAgY2xvc2VUYWcsXG4gICAgICAgICAgIG9ubHlBbGxvd1RhZ3M6IG9wdGlvbnMub25seUFsbG93VGFncyxcbiAgICAgICAgICAgY29udGV4dEZyZWVUYWdzOiBvcHRpb25zLmNvbnRleHRGcmVlVGFncyxcbiAgICAgICAgICAgZW5hYmxlRXNjYXBlVGFnczogb3B0aW9ucy5lbmFibGVFc2NhcGVUYWdzXG4gICAgICAgfSk7XG4gICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgdG9rZW5pemVyLnRva2VuaXplKCk7XG4gICAgICAgLy8gaGFuZGxlcyBzaXR1YXRpb25zIHdoZXJlIHdlIG9wZW4gdGFnLCBidXQgZm9yZ290IGNsb3NlIHRoZW1cbiAgICAgICAvLyBmb3IgZXggW3FddGVzdFsvcV1bdV1zb21lWy91XVtxXXNvbWUgW3Vdc29tZVsvdV0gLy8gZm9yZ290IHRvIGNsb3NlIFsvcV1cbiAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIGZsdXNoIG5lc3RlZCBjb250ZW50IHRvIG5vZGVzIGFycmF5XG4gICAgICAgY29uc3QgbGFzdE5lc3RlZE5vZGUgPSBuZXN0ZWROb2Rlcy5mbHVzaExhc3QoKTtcbiAgICAgICBpZiAobGFzdE5lc3RlZE5vZGUgJiYgaXNUYWdOZXN0ZWQobGFzdE5lc3RlZE5vZGUudGFnKSkge1xuICAgICAgICAgICBhcHBlbmROb2RlQXNTdHJpbmcobGFzdE5lc3RlZE5vZGUsIGZhbHNlKTtcbiAgICAgICB9XG4gICAgICAgcmV0dXJuIG5vZGVzLnRvQXJyYXkoKTtcbiAgIH07XG5cbiAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnVGFnTm9kZScsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBsdWdpbkhlbHBlci5UYWdOb2RlOyB9XG4gICB9KTtcbiAgIGV4cG9ydHMuZGVmYXVsdCA9IHBhcnNlO1xuICAgZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuXG4gICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@bbob/parser/dist/index.js\n"));

/***/ }),

/***/ "./node_modules/@bbob/plugin-helper/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@bbob/plugin-helper/dist/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("(function (global, factory) {\n     true ? factory(exports) :\n    0;\n})(this, (function (exports) { 'use strict';\n\n    const N = '\\n';\n    const TAB = '\\t';\n    const F = '\\f';\n    const R = '\\r';\n    const EQ = '=';\n    const QUOTEMARK = '\"';\n    const SPACE = ' ';\n    const OPEN_BRAKET = '[';\n    const CLOSE_BRAKET = ']';\n    const SLASH = '/';\n    const BACKSLASH = '\\\\';\n\n    const isTagNode = (el)=>typeof el === 'object' && !!el.tag;\n    const isStringNode = (el)=>typeof el === 'string';\n    const isEOL = (el)=>el === N;\n    const keysReduce = (obj, reduce, def)=>Object.keys(obj).reduce(reduce, def);\n    const getNodeLength = (node)=>{\n        if (isTagNode(node)) {\n            return node.content.reduce((count, contentNode)=>count + getNodeLength(contentNode), 0);\n        }\n        if (isStringNode(node)) {\n            return node.length;\n        }\n        return 0;\n    };\n    /**\n     * Appends value to Tag Node\n     * @param {TagNode} node\n     * @param value\n     */ const appendToNode = (node, value)=>{\n        node.content.push(value);\n    };\n    /**\n     * Replaces \" to &qquot;\n     * @param {String} value\n     */ const escapeHTML = (value)=>value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#039;')// eslint-disable-next-line no-script-url\n        .replace(/(javascript|data|vbscript):/gi, '$1%3A');\n    /**\n     * Acept name and value and return valid html5 attribute string\n     * @param {String} name\n     * @param {String} value\n     * @return {string}\n     */ const attrValue = (name, value)=>{\n        const type = typeof value;\n        const types = {\n            boolean: ()=>value ? `${name}` : '',\n            number: ()=>`${name}=\"${value}\"`,\n            string: ()=>`${name}=\"${escapeHTML(value)}\"`,\n            object: ()=>`${name}=\"${escapeHTML(JSON.stringify(value))}\"`\n        };\n        return types[type] ? types[type]() : '';\n    };\n    /**\n     * Transforms attrs to html params string\n     * @param values\n     */ const attrsToString = (values)=>{\n        // To avoid some malformed attributes\n        if (values == null) {\n            return '';\n        }\n        return keysReduce(values, (arr, key)=>[\n                ...arr,\n                attrValue(key, values[key])\n            ], [\n            ''\n        ]).join(' ');\n    };\n    /**\n     * Gets value from\n     * @example\n     * getUniqAttr({ 'foo': true, 'bar': bar' }) => 'bar'\n     * @param attrs\n     * @returns {string}\n     */ const getUniqAttr = (attrs)=>keysReduce(attrs, (res, key)=>attrs[key] === key ? attrs[key] : null, null);\n\n    const getTagAttrs = (tag, params)=>{\n        const uniqAattr = getUniqAttr(params);\n        if (uniqAattr) {\n            const tagAttr = attrValue(tag, uniqAattr);\n            const attrs = {\n                ...params\n            };\n            delete attrs[uniqAattr];\n            const attrsStr = attrsToString(attrs);\n            return `${tagAttr}${attrsStr}`;\n        }\n        return `${tag}${attrsToString(params)}`;\n    };\n    class TagNode {\n        attr(name, value) {\n            if (typeof value !== 'undefined') {\n                this.attrs[name] = value;\n            }\n            return this.attrs[name];\n        }\n        append(value) {\n            return appendToNode(this, value);\n        }\n        get length() {\n            return getNodeLength(this);\n        }\n        toTagStart({ openTag =OPEN_BRAKET , closeTag =CLOSE_BRAKET  } = {}) {\n            const tagAttrs = getTagAttrs(this.tag, this.attrs);\n            return `${openTag}${tagAttrs}${closeTag}`;\n        }\n        toTagEnd({ openTag =OPEN_BRAKET , closeTag =CLOSE_BRAKET  } = {}) {\n            return `${openTag}${SLASH}${this.tag}${closeTag}`;\n        }\n        toTagNode() {\n            return new TagNode(this.tag.toLowerCase(), this.attrs, this.content);\n        }\n        toString({ openTag =OPEN_BRAKET , closeTag =CLOSE_BRAKET  } = {}) {\n            const isEmpty = this.content.length === 0;\n            const content = this.content.reduce((r, node)=>r + node.toString({\n                    openTag,\n                    closeTag\n                }), '');\n            const tagStart = this.toTagStart({\n                openTag,\n                closeTag\n            });\n            if (isEmpty) {\n                return tagStart;\n            }\n            return `${tagStart}${content}${this.toTagEnd({\n            openTag,\n            closeTag\n        })}`;\n        }\n        constructor(tag, attrs, content){\n            this.tag = tag;\n            this.attrs = attrs;\n            this.content = Array.isArray(content) ? content : [\n                content\n            ];\n        }\n    }\n    TagNode.create = (tag, attrs = {}, content = [])=>new TagNode(tag, attrs, content);\n    TagNode.isOf = (node, type)=>node.tag === type;\n\n    exports.BACKSLASH = BACKSLASH;\n    exports.CLOSE_BRAKET = CLOSE_BRAKET;\n    exports.EQ = EQ;\n    exports.F = F;\n    exports.N = N;\n    exports.OPEN_BRAKET = OPEN_BRAKET;\n    exports.QUOTEMARK = QUOTEMARK;\n    exports.R = R;\n    exports.SLASH = SLASH;\n    exports.SPACE = SPACE;\n    exports.TAB = TAB;\n    exports.TagNode = TagNode;\n    exports.appendToNode = appendToNode;\n    exports.attrValue = attrValue;\n    exports.attrsToString = attrsToString;\n    exports.escapeHTML = escapeHTML;\n    exports.getNodeLength = getNodeLength;\n    exports.getUniqAttr = getUniqAttr;\n    exports.isEOL = isEOL;\n    exports.isStringNode = isStringNode;\n    exports.isTagNode = isTagNode;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJib2IvcGx1Z2luLWhlbHBlci9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBSSxLQUE0RDtBQUNoRSxJQUFJLENBQ2lIO0FBQ3JILENBQUMsOEJBQThCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsOERBQThELHNCQUFzQixzQkFBc0Isd0JBQXdCLHdCQUF3QjtBQUMxSjtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsS0FBSztBQUN6QywyQkFBMkIsS0FBSyxJQUFJLE1BQU07QUFDMUMsMkJBQTJCLEtBQUssSUFBSSxrQkFBa0I7QUFDdEQsMkJBQTJCLEtBQUssSUFBSSxrQ0FBa0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBCQUEwQjtBQUMvQztBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUSxFQUFFLFNBQVM7QUFDekM7QUFDQSxrQkFBa0IsSUFBSSxFQUFFLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlEQUFpRCxJQUFJO0FBQzFFO0FBQ0Esc0JBQXNCLFFBQVEsRUFBRSxTQUFTLEVBQUUsU0FBUztBQUNwRDtBQUNBLG1CQUFtQixpREFBaUQsSUFBSTtBQUN4RSxzQkFBc0IsUUFBUSxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpREFBaUQsSUFBSTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVMsRUFBRSxRQUFRLEVBQUU7QUFDM0M7QUFDQTtBQUNBLFNBQVMsRUFBRTtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJib2IvcGx1Z2luLWhlbHBlci9kaXN0L2luZGV4LmpzPzEzNmMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5CYm9iUGx1Z2luSGVscGVyID0ge30pKTtcbn0pKHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBOID0gJ1xcbic7XG4gICAgY29uc3QgVEFCID0gJ1xcdCc7XG4gICAgY29uc3QgRiA9ICdcXGYnO1xuICAgIGNvbnN0IFIgPSAnXFxyJztcbiAgICBjb25zdCBFUSA9ICc9JztcbiAgICBjb25zdCBRVU9URU1BUksgPSAnXCInO1xuICAgIGNvbnN0IFNQQUNFID0gJyAnO1xuICAgIGNvbnN0IE9QRU5fQlJBS0VUID0gJ1snO1xuICAgIGNvbnN0IENMT1NFX0JSQUtFVCA9ICddJztcbiAgICBjb25zdCBTTEFTSCA9ICcvJztcbiAgICBjb25zdCBCQUNLU0xBU0ggPSAnXFxcXCc7XG5cbiAgICBjb25zdCBpc1RhZ05vZGUgPSAoZWwpPT50eXBlb2YgZWwgPT09ICdvYmplY3QnICYmICEhZWwudGFnO1xuICAgIGNvbnN0IGlzU3RyaW5nTm9kZSA9IChlbCk9PnR5cGVvZiBlbCA9PT0gJ3N0cmluZyc7XG4gICAgY29uc3QgaXNFT0wgPSAoZWwpPT5lbCA9PT0gTjtcbiAgICBjb25zdCBrZXlzUmVkdWNlID0gKG9iaiwgcmVkdWNlLCBkZWYpPT5PYmplY3Qua2V5cyhvYmopLnJlZHVjZShyZWR1Y2UsIGRlZik7XG4gICAgY29uc3QgZ2V0Tm9kZUxlbmd0aCA9IChub2RlKT0+e1xuICAgICAgICBpZiAoaXNUYWdOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jb250ZW50LnJlZHVjZSgoY291bnQsIGNvbnRlbnROb2RlKT0+Y291bnQgKyBnZXROb2RlTGVuZ3RoKGNvbnRlbnROb2RlKSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaW5nTm9kZShub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXBwZW5kcyB2YWx1ZSB0byBUYWcgTm9kZVxuICAgICAqIEBwYXJhbSB7VGFnTm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqLyBjb25zdCBhcHBlbmRUb05vZGUgPSAobm9kZSwgdmFsdWUpPT57XG4gICAgICAgIG5vZGUuY29udGVudC5wdXNoKHZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIFwiIHRvICZxcXVvdDtcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi8gY29uc3QgZXNjYXBlSFRNTCA9ICh2YWx1ZSk9PnZhbHVlLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoLz4vZywgJyZndDsnKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JykucmVwbGFjZSgvJy9nLCAnJiMwMzk7JykvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2NyaXB0LXVybFxuICAgICAgICAucmVwbGFjZSgvKGphdmFzY3JpcHR8ZGF0YXx2YnNjcmlwdCk6L2dpLCAnJDElM0EnKTtcbiAgICAvKipcbiAgICAgKiBBY2VwdCBuYW1lIGFuZCB2YWx1ZSBhbmQgcmV0dXJuIHZhbGlkIGh0bWw1IGF0dHJpYnV0ZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi8gY29uc3QgYXR0clZhbHVlID0gKG5hbWUsIHZhbHVlKT0+e1xuICAgICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICBjb25zdCB0eXBlcyA9IHtcbiAgICAgICAgICAgIGJvb2xlYW46ICgpPT52YWx1ZSA/IGAke25hbWV9YCA6ICcnLFxuICAgICAgICAgICAgbnVtYmVyOiAoKT0+YCR7bmFtZX09XCIke3ZhbHVlfVwiYCxcbiAgICAgICAgICAgIHN0cmluZzogKCk9PmAke25hbWV9PVwiJHtlc2NhcGVIVE1MKHZhbHVlKX1cImAsXG4gICAgICAgICAgICBvYmplY3Q6ICgpPT5gJHtuYW1lfT1cIiR7ZXNjYXBlSFRNTChKU09OLnN0cmluZ2lmeSh2YWx1ZSkpfVwiYFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdHlwZXNbdHlwZV0gPyB0eXBlc1t0eXBlXSgpIDogJyc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGF0dHJzIHRvIGh0bWwgcGFyYW1zIHN0cmluZ1xuICAgICAqIEBwYXJhbSB2YWx1ZXNcbiAgICAgKi8gY29uc3QgYXR0cnNUb1N0cmluZyA9ICh2YWx1ZXMpPT57XG4gICAgICAgIC8vIFRvIGF2b2lkIHNvbWUgbWFsZm9ybWVkIGF0dHJpYnV0ZXNcbiAgICAgICAgaWYgKHZhbHVlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleXNSZWR1Y2UodmFsdWVzLCAoYXJyLCBrZXkpPT5bXG4gICAgICAgICAgICAgICAgLi4uYXJyLFxuICAgICAgICAgICAgICAgIGF0dHJWYWx1ZShrZXksIHZhbHVlc1trZXldKVxuICAgICAgICAgICAgXSwgW1xuICAgICAgICAgICAgJydcbiAgICAgICAgXSkuam9pbignICcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB2YWx1ZSBmcm9tXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBnZXRVbmlxQXR0cih7ICdmb28nOiB0cnVlLCAnYmFyJzogYmFyJyB9KSA9PiAnYmFyJ1xuICAgICAqIEBwYXJhbSBhdHRyc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovIGNvbnN0IGdldFVuaXFBdHRyID0gKGF0dHJzKT0+a2V5c1JlZHVjZShhdHRycywgKHJlcywga2V5KT0+YXR0cnNba2V5XSA9PT0ga2V5ID8gYXR0cnNba2V5XSA6IG51bGwsIG51bGwpO1xuXG4gICAgY29uc3QgZ2V0VGFnQXR0cnMgPSAodGFnLCBwYXJhbXMpPT57XG4gICAgICAgIGNvbnN0IHVuaXFBYXR0ciA9IGdldFVuaXFBdHRyKHBhcmFtcyk7XG4gICAgICAgIGlmICh1bmlxQWF0dHIpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZ0F0dHIgPSBhdHRyVmFsdWUodGFnLCB1bmlxQWF0dHIpO1xuICAgICAgICAgICAgY29uc3QgYXR0cnMgPSB7XG4gICAgICAgICAgICAgICAgLi4ucGFyYW1zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGVsZXRlIGF0dHJzW3VuaXFBYXR0cl07XG4gICAgICAgICAgICBjb25zdCBhdHRyc1N0ciA9IGF0dHJzVG9TdHJpbmcoYXR0cnMpO1xuICAgICAgICAgICAgcmV0dXJuIGAke3RhZ0F0dHJ9JHthdHRyc1N0cn1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt0YWd9JHthdHRyc1RvU3RyaW5nKHBhcmFtcyl9YDtcbiAgICB9O1xuICAgIGNsYXNzIFRhZ05vZGUge1xuICAgICAgICBhdHRyKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0cnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dHJzW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGFwcGVuZCh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcGVuZFRvTm9kZSh0aGlzLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXROb2RlTGVuZ3RoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRvVGFnU3RhcnQoeyBvcGVuVGFnID1PUEVOX0JSQUtFVCAsIGNsb3NlVGFnID1DTE9TRV9CUkFLRVQgIH0gPSB7fSkge1xuICAgICAgICAgICAgY29uc3QgdGFnQXR0cnMgPSBnZXRUYWdBdHRycyh0aGlzLnRhZywgdGhpcy5hdHRycyk7XG4gICAgICAgICAgICByZXR1cm4gYCR7b3BlblRhZ30ke3RhZ0F0dHJzfSR7Y2xvc2VUYWd9YDtcbiAgICAgICAgfVxuICAgICAgICB0b1RhZ0VuZCh7IG9wZW5UYWcgPU9QRU5fQlJBS0VUICwgY2xvc2VUYWcgPUNMT1NFX0JSQUtFVCAgfSA9IHt9KSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7b3BlblRhZ30ke1NMQVNIfSR7dGhpcy50YWd9JHtjbG9zZVRhZ31gO1xuICAgICAgICB9XG4gICAgICAgIHRvVGFnTm9kZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGFnTm9kZSh0aGlzLnRhZy50b0xvd2VyQ2FzZSgpLCB0aGlzLmF0dHJzLCB0aGlzLmNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRvU3RyaW5nKHsgb3BlblRhZyA9T1BFTl9CUkFLRVQgLCBjbG9zZVRhZyA9Q0xPU0VfQlJBS0VUICB9ID0ge30pIHtcbiAgICAgICAgICAgIGNvbnN0IGlzRW1wdHkgPSB0aGlzLmNvbnRlbnQubGVuZ3RoID09PSAwO1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuY29udGVudC5yZWR1Y2UoKHIsIG5vZGUpPT5yICsgbm9kZS50b1N0cmluZyh7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5UYWcsXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlVGFnXG4gICAgICAgICAgICAgICAgfSksICcnKTtcbiAgICAgICAgICAgIGNvbnN0IHRhZ1N0YXJ0ID0gdGhpcy50b1RhZ1N0YXJ0KHtcbiAgICAgICAgICAgICAgICBvcGVuVGFnLFxuICAgICAgICAgICAgICAgIGNsb3NlVGFnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhZ1N0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGAke3RhZ1N0YXJ0fSR7Y29udGVudH0ke3RoaXMudG9UYWdFbmQoe1xuICAgICAgICAgICAgb3BlblRhZyxcbiAgICAgICAgICAgIGNsb3NlVGFnXG4gICAgICAgIH0pfWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3RydWN0b3IodGFnLCBhdHRycywgY29udGVudCl7XG4gICAgICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgICAgIHRoaXMuY29udGVudCA9IEFycmF5LmlzQXJyYXkoY29udGVudCkgPyBjb250ZW50IDogW1xuICAgICAgICAgICAgICAgIGNvbnRlbnRcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgVGFnTm9kZS5jcmVhdGUgPSAodGFnLCBhdHRycyA9IHt9LCBjb250ZW50ID0gW10pPT5uZXcgVGFnTm9kZSh0YWcsIGF0dHJzLCBjb250ZW50KTtcbiAgICBUYWdOb2RlLmlzT2YgPSAobm9kZSwgdHlwZSk9Pm5vZGUudGFnID09PSB0eXBlO1xuXG4gICAgZXhwb3J0cy5CQUNLU0xBU0ggPSBCQUNLU0xBU0g7XG4gICAgZXhwb3J0cy5DTE9TRV9CUkFLRVQgPSBDTE9TRV9CUkFLRVQ7XG4gICAgZXhwb3J0cy5FUSA9IEVRO1xuICAgIGV4cG9ydHMuRiA9IEY7XG4gICAgZXhwb3J0cy5OID0gTjtcbiAgICBleHBvcnRzLk9QRU5fQlJBS0VUID0gT1BFTl9CUkFLRVQ7XG4gICAgZXhwb3J0cy5RVU9URU1BUksgPSBRVU9URU1BUks7XG4gICAgZXhwb3J0cy5SID0gUjtcbiAgICBleHBvcnRzLlNMQVNIID0gU0xBU0g7XG4gICAgZXhwb3J0cy5TUEFDRSA9IFNQQUNFO1xuICAgIGV4cG9ydHMuVEFCID0gVEFCO1xuICAgIGV4cG9ydHMuVGFnTm9kZSA9IFRhZ05vZGU7XG4gICAgZXhwb3J0cy5hcHBlbmRUb05vZGUgPSBhcHBlbmRUb05vZGU7XG4gICAgZXhwb3J0cy5hdHRyVmFsdWUgPSBhdHRyVmFsdWU7XG4gICAgZXhwb3J0cy5hdHRyc1RvU3RyaW5nID0gYXR0cnNUb1N0cmluZztcbiAgICBleHBvcnRzLmVzY2FwZUhUTUwgPSBlc2NhcGVIVE1MO1xuICAgIGV4cG9ydHMuZ2V0Tm9kZUxlbmd0aCA9IGdldE5vZGVMZW5ndGg7XG4gICAgZXhwb3J0cy5nZXRVbmlxQXR0ciA9IGdldFVuaXFBdHRyO1xuICAgIGV4cG9ydHMuaXNFT0wgPSBpc0VPTDtcbiAgICBleHBvcnRzLmlzU3RyaW5nTm9kZSA9IGlzU3RyaW5nTm9kZTtcbiAgICBleHBvcnRzLmlzVGFnTm9kZSA9IGlzVGFnTm9kZTtcblxufSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@bbob/plugin-helper/dist/index.js\n"));

/***/ }),

/***/ "./src/features/thread/ui/thread.tsx":
/*!*******************************************!*\
  !*** ./src/features/thread/ui/thread.tsx ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Thread: function() { return /* binding */ Thread; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"./node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/link */ \"./node_modules/next/link.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _model_use_modal_thread__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../model/use-modal-thread */ \"./src/features/thread/model/use-modal-thread.tsx\");\n/* harmony import */ var _bbob_parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @bbob/parser */ \"./node_modules/@bbob/parser/dist/index.js\");\n/* harmony import */ var _bbob_parser__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_bbob_parser__WEBPACK_IMPORTED_MODULE_4__);\n\nvar _s = $RefreshSig$();\n\n\n\n\n_bbob_parser__WEBPACK_IMPORTED_MODULE_4__.parse;\nfunction Thread(param) {\n    let { date, number, content, pictures, desk, isFirst, postsCount, picturesCount, thread, index } = param;\n    _s();\n    const { onMouseDown, onMouseUp, scale, setModalImage, modalImage, onMouseMove, onWheel, handleClick, modalPosition } = (0,_model_use_modal_thread__WEBPACK_IMPORTED_MODULE_3__.useModalThread)();\n    const picPostCount = pictures === null || pictures === void 0 ? void 0 : pictures.length;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex mb-[6px]\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"flex flex-col min-h-[80px] w-auto rounded-sm pr-7\", !isFirst && \"bg-post-color\"),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex flex-row pl-2 pt-1   \",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"text-zinc-800\",\n                                children: [\n                                    \"Аноним \",\n                                    \" \",\n                                    isFirst && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"text-green-500 \",\n                                        children: \"#OP\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\jkmuf_000\\\\Desktop\\\\laravel_study\\\\client\\\\src\\\\features\\\\thread\\\\ui\\\\thread.tsx\",\n                                        lineNumber: 56,\n                                        columnNumber: 25\n                                    }, this),\n                                    \" \",\n                                    date,\n                                    \" №\",\n                                    number,\n                                    \" \",\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"text-green-700\",\n                                        children: index != undefined ? index + 1 : \"\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\jkmuf_000\\\\Desktop\\\\laravel_study\\\\client\\\\src\\\\features\\\\thread\\\\ui\\\\thread.tsx\",\n                                        lineNumber: 58,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\jkmuf_000\\\\Desktop\\\\laravel_study\\\\client\\\\src\\\\features\\\\thread\\\\ui\\\\thread.tsx\",\n                                lineNumber: 54,\n                                columnNumber: 11\n                            }, this),\n                            isFirst && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_2___default()), {\n                                href: \"\".concat(desk, \"/res/\").concat(thread),\n                                className: \"ml-1 text-orange-600 hover:text-orange-700\",\n                                children: \"Ответ\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\jkmuf_000\\\\Desktop\\\\laravel_study\\\\client\\\\src\\\\features\\\\thread\\\\ui\\\\thread.tsx\",\n                                lineNumber: 63,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\jkmuf_000\\\\Desktop\\\\laravel_study\\\\client\\\\src\\\\features\\\\thread\\\\ui\\\\thread.tsx\",\n                        lineNumber: 53,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        /*КАРТИНКА + ТЕКСТ*/ className: (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"flex pb-1 \", picPostCount > 1 ? \"flex flex-col\" : \"flex flex-row\"),\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(picPostCount > 1 && picPostCount < 4 && \"flex-row\", picPostCount === 1 && \"flex-col\", picPostCount > 3 && \"flex-wrap\", \"flex \"),\n                                children: pictures === null || pictures === undefined ? \"\" : pictures.map((picture, index, array)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(index != array.length - 1 ? \"max-w-content mb-1\" : \"w-full mb-2\"),\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                            src: \"http://127.0.0.1:8000/thumbnails/\".concat(picture),\n                                            alt: \"\",\n                                            className: \"cursor-pointer pl-3 pt-2\",\n                                            onClick: ()=>setModalImage(picture)\n                                        }, index, false, {\n                                            fileName: \"C:\\\\Users\\\\jkmuf_000\\\\Desktop\\\\laravel_study\\\\client\\\\src\\\\features\\\\thread\\\\ui\\\\thread.tsx\",\n                                            lineNumber: 93,\n                                            columnNumber: 21\n                                        }, this)\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\jkmuf_000\\\\Desktop\\\\laravel_study\\\\client\\\\src\\\\features\\\\thread\\\\ui\\\\thread.tsx\",\n                                        lineNumber: 88,\n                                        columnNumber: 19\n                                    }, this))\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\jkmuf_000\\\\Desktop\\\\laravel_study\\\\client\\\\src\\\\features\\\\thread\\\\ui\\\\thread.tsx\",\n                                lineNumber: 77,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"text-base pl-4 py-3\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"pre\", {\n                                    children: content\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\jkmuf_000\\\\Desktop\\\\laravel_study\\\\client\\\\src\\\\features\\\\thread\\\\ui\\\\thread.tsx\",\n                                    lineNumber: 104,\n                                    columnNumber: 13\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\jkmuf_000\\\\Desktop\\\\laravel_study\\\\client\\\\src\\\\features\\\\thread\\\\ui\\\\thread.tsx\",\n                                lineNumber: 103,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\jkmuf_000\\\\Desktop\\\\laravel_study\\\\client\\\\src\\\\features\\\\thread\\\\ui\\\\thread.tsx\",\n                        lineNumber: 71,\n                        columnNumber: 9\n                    }, this),\n                    isFirst && /* КОНЕЦ КАРТИНКА + ТЕКСТ*/ /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                            children: [\n                                postsCount,\n                                \" постов, \",\n                                picturesCount,\n                                \" медиа\"\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\jkmuf_000\\\\Desktop\\\\laravel_study\\\\client\\\\src\\\\features\\\\thread\\\\ui\\\\thread.tsx\",\n                            lineNumber: 109,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\jkmuf_000\\\\Desktop\\\\laravel_study\\\\client\\\\src\\\\features\\\\thread\\\\ui\\\\thread.tsx\",\n                        lineNumber: 108,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\jkmuf_000\\\\Desktop\\\\laravel_study\\\\client\\\\src\\\\features\\\\thread\\\\ui\\\\thread.tsx\",\n                lineNumber: 47,\n                columnNumber: 7\n            }, this),\n            modalImage && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"fixed top-0 left-0 w-full h-full flex items-center justify-center\",\n                onMouseDown: onMouseDown,\n                onWheel: onWheel,\n                onMouseMove: onMouseMove,\n                onMouseUp: onMouseUp,\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                    src: \"http://127.0.0.1:8000/\".concat(modalImage),\n                    alt: \"\",\n                    className: \"max-w-full max-h-full border-8 border-modal-color\",\n                    onClick: handleClick,\n                    style: {\n                        transform: \"translate(\".concat(modalPosition.x, \"px, \").concat(modalPosition.y, \"px) scale(\").concat(scale, \")\")\n                    }\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\jkmuf_000\\\\Desktop\\\\laravel_study\\\\client\\\\src\\\\features\\\\thread\\\\ui\\\\thread.tsx\",\n                    lineNumber: 123,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\jkmuf_000\\\\Desktop\\\\laravel_study\\\\client\\\\src\\\\features\\\\thread\\\\ui\\\\thread.tsx\",\n                lineNumber: 116,\n                columnNumber: 9\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\jkmuf_000\\\\Desktop\\\\laravel_study\\\\client\\\\src\\\\features\\\\thread\\\\ui\\\\thread.tsx\",\n        lineNumber: 46,\n        columnNumber: 5\n    }, this);\n}\n_s(Thread, \"ogILnGtB58Ohla01WTPKGaod6Uk=\", false, function() {\n    return [\n        _model_use_modal_thread__WEBPACK_IMPORTED_MODULE_3__.useModalThread\n    ];\n});\n_c = Thread;\nvar _c;\n$RefreshReg$(_c, \"Thread\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZmVhdHVyZXMvdGhyZWFkL3VpL3RocmVhZC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF3QjtBQUNLO0FBQzhCO0FBQ3RCO0FBQ3JDRywrQ0FBS0E7QUFjRSxTQUFTQyxPQUFPLEtBV1Q7UUFYUyxFQUNyQkMsSUFBSSxFQUNKQyxNQUFNLEVBQ05DLE9BQU8sRUFDUEMsUUFBUSxFQUNSQyxJQUFJLEVBQ0pDLE9BQU8sRUFDUEMsVUFBVSxFQUNWQyxhQUFhLEVBQ2JDLE1BQU0sRUFDTkMsS0FBSyxFQUNPLEdBWFM7O0lBWXJCLE1BQU0sRUFDSkMsV0FBVyxFQUNYQyxTQUFTLEVBQ1RDLEtBQUssRUFDTEMsYUFBYSxFQUNiQyxVQUFVLEVBQ1ZDLFdBQVcsRUFDWEMsT0FBTyxFQUNQQyxXQUFXLEVBQ1hDLGFBQWEsRUFDZCxHQUFHckIsdUVBQWNBO0lBRWxCLE1BQU1zQixlQUFlaEIscUJBQUFBLCtCQUFBQSxTQUFVaUIsTUFBTTtJQUVyQyxxQkFDRSw4REFBQ0M7UUFBSUMsV0FBVTs7MEJBQ2IsOERBQUNEO2dCQUNDQyxXQUFXM0IsZ0RBQUlBLENBQ2IscURBQ0EsQ0FBQ1UsV0FBVzs7a0NBR2QsOERBQUNnQjt3QkFBSUMsV0FBVTs7MENBQ2IsOERBQUNDO2dDQUFLRCxXQUFVOztvQ0FDWjtvQ0FBVTtvQ0FDWGpCLHlCQUFXLDhEQUFDa0I7d0NBQUtELFdBQVU7a0RBQWtCOzs7Ozs7b0NBQVc7b0NBQUV0QjtvQ0FBSztvQ0FDL0RDO29DQUFRO2tEQUNULDhEQUFDc0I7d0NBQUtELFdBQVU7a0RBQ2JiLFNBQVNlLFlBQVlmLFFBQVEsSUFBSTs7Ozs7Ozs7Ozs7OzRCQUdyQ0oseUJBQ0MsOERBQUNULGtEQUFJQTtnQ0FDSDZCLE1BQU0sR0FBZWpCLE9BQVpKLE1BQUssU0FBYyxPQUFQSTtnQ0FDckJjLFdBQVU7MENBQ1g7Ozs7Ozs7Ozs7OztrQ0FLTCw4REFBQ0Q7d0JBQXlCLGtCQUFrQixHQUMxQ0MsV0FBVzNCLGdEQUFJQSxDQUNiLGNBQ0F3QixlQUFlLElBQUksa0JBQWtCOzswQ0FHdkMsOERBQUNFO2dDQUNDQyxXQUFXM0IsZ0RBQUlBLENBQ2J3QixlQUFlLEtBQUtBLGVBQWUsS0FBSyxZQUN4Q0EsaUJBQWlCLEtBQUssWUFDdEJBLGVBQWUsS0FBSyxhQUNwQjswQ0FHRGhCLGFBQWEsUUFBUUEsYUFBYXFCLFlBQy9CLEtBQ0FyQixTQUFTdUIsR0FBRyxDQUFDLENBQUNDLFNBQVNsQixPQUFPbUIsc0JBQzVCLDhEQUFDUDt3Q0FDQ0MsV0FBVzNCLGdEQUFJQSxDQUNiYyxTQUFTbUIsTUFBTVIsTUFBTSxHQUFHLElBQUksdUJBQXVCO2tEQUdyRCw0RUFBQ1M7NENBQ0NDLEtBQUssb0NBQTRDLE9BQVJIOzRDQUN6Q0ksS0FBSzs0Q0FDTFQsV0FBVTs0Q0FFVlUsU0FBUyxJQUFNbkIsY0FBY2M7MkNBRHhCbEI7Ozs7Ozs7Ozs7Ozs7OzswQ0FNakIsOERBQUNjO2dDQUFLRCxXQUFVOzBDQUNkLDRFQUFDVzs4Q0FBSy9COzs7Ozs7Ozs7Ozs7Ozs7OztvQkFHVEcsV0FBaUIseUJBQXlCLGlCQUN6Qyw4REFBQ2dCO2tDQUNDLDRFQUFDRTs7Z0NBQ0VqQjtnQ0FBVztnQ0FBVUM7Z0NBQWM7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQUszQ08sNEJBQ0MsOERBQUNPO2dCQUNDQyxXQUFVO2dCQUNWWixhQUFhQTtnQkFDYk0sU0FBU0E7Z0JBQ1RELGFBQWFBO2dCQUNiSixXQUFXQTswQkFFWCw0RUFBQ2tCO29CQUNDQyxLQUFLLHlCQUFvQyxPQUFYaEI7b0JBQzlCaUIsS0FBSTtvQkFDSlQsV0FBVTtvQkFDVlUsU0FBU2Y7b0JBQ1RpQixPQUFPO3dCQUNMQyxXQUFXLGFBQW1DakIsT0FBdEJBLGNBQWNrQixDQUFDLEVBQUMsUUFBa0N4QixPQUE1Qk0sY0FBY21CLENBQUMsRUFBQyxjQUFrQixPQUFOekIsT0FBTTtvQkFDbEY7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTVo7R0FySGdCYjs7UUFzQlZGLG1FQUFjQTs7O0tBdEJKRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZmVhdHVyZXMvdGhyZWFkL3VpL3RocmVhZC50c3g/ODEyZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY2xzeCBmcm9tIFwiY2xzeFwiO1xyXG5pbXBvcnQgTGluayBmcm9tIFwibmV4dC9saW5rXCI7XHJcbmltcG9ydCB7IHVzZU1vZGFsVGhyZWFkIH0gZnJvbSBcIi4uL21vZGVsL3VzZS1tb2RhbC10aHJlYWRcIjtcclxuaW1wb3J0IHsgcGFyc2UgfSBmcm9tIFwiQGJib2IvcGFyc2VyXCI7XHJcbnBhcnNlXHJcblxyXG50eXBlIFRocmVhZFByb3BzID0ge1xyXG4gIGRhdGU6IHN0cmluZztcclxuICBudW1iZXI6IG51bWJlcjtcclxuICBjb250ZW50OiBzdHJpbmc7XHJcbiAgcGljdHVyZXM6IHN0cmluZ1tdO1xyXG4gIGRlc2s6IHN0cmluZztcclxuICBpc0ZpcnN0PzogYm9vbGVhbjtcclxuICBwb3N0c0NvdW50PzogbnVtYmVyO1xyXG4gIHBpY3R1cmVzQ291bnQ/OiBudW1iZXI7XHJcbiAgdGhyZWFkPzogbnVtYmVyO1xyXG4gIGluZGV4PzogbnVtYmVyO1xyXG59O1xyXG5leHBvcnQgZnVuY3Rpb24gVGhyZWFkKHtcclxuICBkYXRlLFxyXG4gIG51bWJlcixcclxuICBjb250ZW50LFxyXG4gIHBpY3R1cmVzLFxyXG4gIGRlc2ssXHJcbiAgaXNGaXJzdCxcclxuICBwb3N0c0NvdW50LFxyXG4gIHBpY3R1cmVzQ291bnQsXHJcbiAgdGhyZWFkLFxyXG4gIGluZGV4LFxyXG59OiBUaHJlYWRQcm9wcykge1xyXG4gIGNvbnN0IHtcclxuICAgIG9uTW91c2VEb3duLFxyXG4gICAgb25Nb3VzZVVwLFxyXG4gICAgc2NhbGUsXHJcbiAgICBzZXRNb2RhbEltYWdlLFxyXG4gICAgbW9kYWxJbWFnZSxcclxuICAgIG9uTW91c2VNb3ZlLFxyXG4gICAgb25XaGVlbCxcclxuICAgIGhhbmRsZUNsaWNrLFxyXG4gICAgbW9kYWxQb3NpdGlvbixcclxuICB9ID0gdXNlTW9kYWxUaHJlYWQoKTtcclxuXHJcbiAgY29uc3QgcGljUG9zdENvdW50ID0gcGljdHVyZXM/Lmxlbmd0aDtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBtYi1bNnB4XVwiPlxyXG4gICAgICA8ZGl2XHJcbiAgICAgICAgY2xhc3NOYW1lPXtjbHN4KFxyXG4gICAgICAgICAgXCJmbGV4IGZsZXgtY29sIG1pbi1oLVs4MHB4XSB3LWF1dG8gcm91bmRlZC1zbSBwci03XCIsXHJcbiAgICAgICAgICAhaXNGaXJzdCAmJiBcImJnLXBvc3QtY29sb3JcIlxyXG4gICAgICAgICl9XHJcbiAgICAgID5cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1yb3cgcGwtMiBwdC0xICAgXCI+ICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXppbmMtODAwXCI+ICAgICAgIFxyXG4gICAgICAgICAgICB7YNCQ0L3QvtC90LjQvCBgfXtcIiBcIn1cclxuICAgICAgICAgICAge2lzRmlyc3QgJiYgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1ncmVlbi01MDAgXCI+I09QPC9zcGFuPn0ge2RhdGV9IOKEllxyXG4gICAgICAgICAgICB7bnVtYmVyfXtcIiBcIn1cclxuICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1ncmVlbi03MDBcIj5cclxuICAgICAgICAgICAgICB7aW5kZXggIT0gdW5kZWZpbmVkID8gaW5kZXggKyAxIDogXCJcIn1cclxuICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAge2lzRmlyc3QgJiYgKFxyXG4gICAgICAgICAgICA8TGlua1xyXG4gICAgICAgICAgICAgIGhyZWY9e2Ake2Rlc2t9L3Jlcy8ke3RocmVhZH1gfVxyXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cIm1sLTEgdGV4dC1vcmFuZ2UtNjAwIGhvdmVyOnRleHQtb3JhbmdlLTcwMFwiXHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICDQntGC0LLQtdGCXHJcbiAgICAgICAgICAgIDwvTGluaz5cclxuICAgICAgICAgICl9XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGRpdiAgICAgICAgICAgICAgICAgICAgICAvKtCa0JDQoNCi0JjQndCa0JAgKyDQotCV0JrQodCiKi9cclxuICAgICAgICAgIGNsYXNzTmFtZT17Y2xzeChcclxuICAgICAgICAgICAgXCJmbGV4IHBiLTEgXCIsXHJcbiAgICAgICAgICAgIHBpY1Bvc3RDb3VudCA+IDEgPyBcImZsZXggZmxleC1jb2xcIiA6IFwiZmxleCBmbGV4LXJvd1wiXHJcbiAgICAgICAgICApfVxyXG4gICAgICAgID5cclxuICAgICAgICAgIDxkaXZcclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbHN4KFxyXG4gICAgICAgICAgICAgIHBpY1Bvc3RDb3VudCA+IDEgJiYgcGljUG9zdENvdW50IDwgNCAmJiBcImZsZXgtcm93XCIsXHJcbiAgICAgICAgICAgICAgcGljUG9zdENvdW50ID09PSAxICYmIFwiZmxleC1jb2xcIixcclxuICAgICAgICAgICAgICBwaWNQb3N0Q291bnQgPiAzICYmIFwiZmxleC13cmFwXCIsXHJcbiAgICAgICAgICAgICAgXCJmbGV4IFwiXHJcbiAgICAgICAgICAgICl9XHJcbiAgICAgICAgICA+XHJcbiAgICAgICAgICAgIHtwaWN0dXJlcyA9PT0gbnVsbCB8fCBwaWN0dXJlcyA9PT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgPyBcIlwiXHJcbiAgICAgICAgICAgICAgOiBwaWN0dXJlcy5tYXAoKHBpY3R1cmUsIGluZGV4LCBhcnJheSkgPT4gKFxyXG4gICAgICAgICAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbHN4KFxyXG4gICAgICAgICAgICAgICAgICAgICAgaW5kZXggIT0gYXJyYXkubGVuZ3RoIC0gMSA/IFwibWF4LXctY29udGVudCBtYi0xXCIgOiBcInctZnVsbCBtYi0yXCJcclxuICAgICAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgPGltZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgc3JjPXtgaHR0cDovLzEyNy4wLjAuMTo4MDAwL3RodW1ibmFpbHMvJHtwaWN0dXJlfWB9XHJcbiAgICAgICAgICAgICAgICAgICAgICBhbHQ9e1wiXCJ9XHJcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJjdXJzb3ItcG9pbnRlciBwbC0zIHB0LTJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAga2V5PXtpbmRleH1cclxuICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldE1vZGFsSW1hZ2UocGljdHVyZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICApKX1cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1iYXNlIHBsLTQgcHktM1wiPlxyXG4gICAgICAgICAgICA8cHJlPntjb250ZW50fTwvcHJlPlxyXG4gICAgICAgICAgPC9zcGFuPlxyXG4gICAgICA8L2Rpdj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICB7aXNGaXJzdCAmJiAoICAgICAvKiDQmtCe0J3QldCmINCa0JDQoNCi0JjQndCa0JAgKyDQotCV0JrQodCiKi9cclxuICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgIDxzcGFuPlxyXG4gICAgICAgICAgICAgIHtwb3N0c0NvdW50fSDQv9C+0YHRgtC+0LIsIHtwaWN0dXJlc0NvdW50fSDQvNC10LTQuNCwXHJcbiAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICl9XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICB7bW9kYWxJbWFnZSAmJiAoXHJcbiAgICAgICAgPGRpdlxyXG4gICAgICAgICAgY2xhc3NOYW1lPVwiZml4ZWQgdG9wLTAgbGVmdC0wIHctZnVsbCBoLWZ1bGwgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXJcIlxyXG4gICAgICAgICAgb25Nb3VzZURvd249e29uTW91c2VEb3dufVxyXG4gICAgICAgICAgb25XaGVlbD17b25XaGVlbH1cclxuICAgICAgICAgIG9uTW91c2VNb3ZlPXtvbk1vdXNlTW92ZX1cclxuICAgICAgICAgIG9uTW91c2VVcD17b25Nb3VzZVVwfVxyXG4gICAgICAgID5cclxuICAgICAgICAgIDxpbWdcclxuICAgICAgICAgICAgc3JjPXtgaHR0cDovLzEyNy4wLjAuMTo4MDAwLyR7bW9kYWxJbWFnZX1gfVxyXG4gICAgICAgICAgICBhbHQ9XCJcIlxyXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJtYXgtdy1mdWxsIG1heC1oLWZ1bGwgYm9yZGVyLTggYm9yZGVyLW1vZGFsLWNvbG9yXCJcclxuICAgICAgICAgICAgb25DbGljaz17aGFuZGxlQ2xpY2t9XHJcbiAgICAgICAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7bW9kYWxQb3NpdGlvbi54fXB4LCAke21vZGFsUG9zaXRpb24ueX1weCkgc2NhbGUoJHtzY2FsZX0pYCxcclxuICAgICAgICAgICAgfX1cclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICl9XHJcbiAgICA8L2Rpdj5cclxuICApO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJjbHN4IiwiTGluayIsInVzZU1vZGFsVGhyZWFkIiwicGFyc2UiLCJUaHJlYWQiLCJkYXRlIiwibnVtYmVyIiwiY29udGVudCIsInBpY3R1cmVzIiwiZGVzayIsImlzRmlyc3QiLCJwb3N0c0NvdW50IiwicGljdHVyZXNDb3VudCIsInRocmVhZCIsImluZGV4Iiwib25Nb3VzZURvd24iLCJvbk1vdXNlVXAiLCJzY2FsZSIsInNldE1vZGFsSW1hZ2UiLCJtb2RhbEltYWdlIiwib25Nb3VzZU1vdmUiLCJvbldoZWVsIiwiaGFuZGxlQ2xpY2siLCJtb2RhbFBvc2l0aW9uIiwicGljUG9zdENvdW50IiwibGVuZ3RoIiwiZGl2IiwiY2xhc3NOYW1lIiwic3BhbiIsInVuZGVmaW5lZCIsImhyZWYiLCJtYXAiLCJwaWN0dXJlIiwiYXJyYXkiLCJpbWciLCJzcmMiLCJhbHQiLCJvbkNsaWNrIiwicHJlIiwic3R5bGUiLCJ0cmFuc2Zvcm0iLCJ4IiwieSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/features/thread/ui/thread.tsx\n"));

/***/ })

});